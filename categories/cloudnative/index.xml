<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CloudNative on ilolicon's Blog</title><link>https://ilolicon.github.io/categories/cloudnative/</link><description>Recent content in CloudNative on ilolicon's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 20 Dec 2020 14:21:14 +0800</lastBuildDate><atom:link href="https://ilolicon.github.io/categories/cloudnative/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes</title><link>https://ilolicon.github.io/p/kubernetes/</link><pubDate>Sun, 20 Dec 2020 14:21:14 +0800</pubDate><guid>https://ilolicon.github.io/p/kubernetes/</guid><description>&lt;p>&lt;a class="link" href="https://kubernetes.io/zh/docs/home/" target="_blank" rel="noopener"
>&lt;img src="https://img.shields.io/badge/Kubernetes-README-356DE3"
loading="lazy"
alt="kubernetes readme"
>&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://kubernetes.io/" target="_blank" rel="noopener"
>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/kubernetes.svg"
loading="lazy"
alt="kubernetes"
>&lt;/a>&lt;/p>
&lt;p>&lt;code>container evolution&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/container_evolution.svg"
loading="lazy"
alt="container_evolution"
>&lt;/p>
&lt;h2 id="容器编排">容器编排&lt;/h2>
&lt;ul>
&lt;li>Ansible/Saltstack &lt;strong>传统应用&lt;/strong>编排工具&lt;/li>
&lt;li>Docker
&lt;ul>
&lt;li>docker compose(docker单机编排)&lt;/li>
&lt;li>docker swarm(docker主机加入docker swarm资源池)&lt;/li>
&lt;li>docker machine(完成docker主机加入docker swarm资源池的先决条件/预处理工具)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Mesos(IDC OS) + marathon(面向容器编排的框架)&lt;/li>
&lt;li>kubernetes(Borg)
&lt;ul>
&lt;li>自动装箱(基于依赖 自动完成容器部署 不影响其可用性)&lt;/li>
&lt;li>自我修复&lt;/li>
&lt;li>水平扩展&lt;/li>
&lt;li>服务发现和负载均衡&lt;/li>
&lt;li>自动发布和回滚&lt;/li>
&lt;li>密钥和配置管理&lt;/li>
&lt;li>存储编排&lt;/li>
&lt;li>任务批量处理运行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>概念: &lt;code>DevOps&lt;/code> &lt;code>MicroServices&lt;/code> &lt;code>Blockchain&lt;/code>&lt;/p>
&lt;ul>
&lt;li>CI: 持续集成&lt;/li>
&lt;li>CD: 持续交互 Delivery&lt;/li>
&lt;li>CD: 持续部署 Deployment&lt;/li>
&lt;/ul>
&lt;h2 id="kubernetes架构概述">Kubernetes架构概述&lt;/h2>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/kubernetes_cluster.png"
width="576"
height="335"
srcset="https://ilolicon.github.io/p/kubernetes/icons/kubernetes_cluster_hu5d0dab3c0d7d17e817e2f0f85b092344_117781_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/kubernetes_cluster_hu5d0dab3c0d7d17e817e2f0f85b092344_117781_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="kubernetes-cluster"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;ul>
&lt;li>有中心节点的集群架构系统(抽象各主机资源 统一对外提供计算)&lt;/li>
&lt;li>Master/Node(Worker)
&lt;ul>
&lt;li>Master
&lt;ul>
&lt;li>etcd: 兼具一致性和高可用性的键值数据库 可以作为保存Kubernetes所有集群数据的后台数据库&lt;/li>
&lt;li>API Server(公开kubernetes API)&lt;/li>
&lt;li>Scheduler(调度器)&lt;/li>
&lt;li>Controller-Manager(控制器)
&lt;ul>
&lt;li>节点控制器(Node Controller): 负责在节点出现故障时进行通知和响应&lt;/li>
&lt;li>任务控制器(Job controller): 监测代表一次性任务的Job对象 然后创建Pods来运行这些任务直至完成&lt;/li>
&lt;li>端点控制器(Endpoints Controller): 填充端点(Endpoints)对象(即加入Service与Pod)&lt;/li>
&lt;li>服务帐户和令牌控制器(Service Account &amp;amp; Token Controllers): 为新的命名空间创建默认帐户和API访问令牌&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Node
&lt;ul>
&lt;li>kubelet: 集群代理 并不运行容器&lt;/li>
&lt;li>kube-proxy: 网络代理 管理Service的创建 更新(iptables/ipvs)&lt;/li>
&lt;li>容器运行时(容器引擎): 运行容器 支持&lt;a class="link" href="https://kubernetes.io/zh/docs/reference/kubectl/docker-cli-to-kubectl/" target="_blank" rel="noopener"
>Docker&lt;/a>/&lt;a class="link" href="https://containerd.io/docs/" target="_blank" rel="noopener"
>containerd&lt;/a>/&lt;a class="link" href="https://cri-o.io/#what-is-cri-o" target="_blank" rel="noopener"
>CRI-O&lt;/a>以及任何实现 &lt;a class="link" href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noopener"
>Kubernetes CRI (容器运行环境接口)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://kubernetes.io/zh/docs/concepts/overview/components/" target="_blank" rel="noopener"
>kubernetes组件&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/kubernetes_cluster02.png"
width="821"
height="568"
srcset="https://ilolicon.github.io/p/kubernetes/icons/kubernetes_cluster02_hu5ddc702c3d24b1f991acd583b33b036e_257528_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/kubernetes_cluster02_hu5ddc702c3d24b1f991acd583b33b036e_257528_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="kuberbetes-cluster02"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/components-of-kubernetes.svg"
loading="lazy"
alt="components-of-kubernetes"
>&lt;/p>
&lt;h2 id="pod">Pod&lt;/h2>
&lt;ul>
&lt;li>Pod
&lt;ul>
&lt;li>自主式Pod&lt;/li>
&lt;li>控制器管理的Pod(建议使用)
&lt;ul>
&lt;li>ReplicationController(副本控制器)&lt;/li>
&lt;li>ReplicaSet(副本集控制器 不直接使用 有一个声明式更新的控制器Deployment)&lt;/li>
&lt;li>Deployment(管理无状态应用)
&lt;ul>
&lt;li>HPA(HorizontalPodAutoscaler) 水平Pod自动伸缩控制器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>StatefulSet(有状态副本集)&lt;/li>
&lt;li>DaemonSet&lt;/li>
&lt;li>Job/CronJob&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Label
&lt;ul>
&lt;li>Label Selector&lt;/li>
&lt;li>Label: key=value&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="service">Service&lt;/h2>
&lt;ul>
&lt;li>iptables的DNAT规则(调度多个service后端 ipvs规则)&lt;/li>
&lt;li>靠标签选择器 关联Pod对象&lt;/li>
&lt;li>service 名称 可以被解析(DNS Pod实现解析 - 基础架构级的Pod)
&lt;ul>
&lt;li>基础架构级Pod &lt;code>AddOns&lt;/code>集群附加组件 支撑其他服务需要使用到的服务&lt;/li>
&lt;li>动态更新DNS解析&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="网络通信">网络通信&lt;/h2>
&lt;ul>
&lt;li>同一个Pod内的多个容器间: lo&lt;/li>
&lt;li>各Pod之间的通信(不直接通信 通过Service通信)
&lt;ul>
&lt;li>二层广播 -&amp;gt; 广播风暴&lt;/li>
&lt;li>Overlay Network 叠加网络
&lt;ul>
&lt;li>需要确保每一个Pod网络地址不会冲突&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Pod和Service之间的通信&lt;/li>
&lt;/ul>
&lt;p>依赖第三方插件(附件) 通过CNI(容器网络接口)接入&lt;/p>
&lt;ul>
&lt;li>flannel: 网络配置 Pod网络-10.244.0.0/16&lt;/li>
&lt;li>calico: 网络配置 网络策略(Pod之间、Namespace&amp;hellip;之间的访问或隔离)&lt;/li>
&lt;li>canel: 上面两种搭配使用&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/k8s-network.png"
width="2156"
height="1074"
srcset="https://ilolicon.github.io/p/kubernetes/icons/k8s-network_hu450a176e8d46831d14cdc75349a18d18_2340849_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/k8s-network_hu450a176e8d46831d14cdc75349a18d18_2340849_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="k8s-network"
class="gallery-image"
data-flex-grow="200"
data-flex-basis="481px"
>&lt;/p>
&lt;h2 id="namespace">Namespace&lt;/h2>
&lt;ul>
&lt;li>管理的边界&lt;/li>
&lt;li>隔离不同名称空间的网络&lt;/li>
&lt;/ul>
&lt;h2 id="初始化kubernetes集群">初始化Kubernetes集群&lt;/h2>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/structure.png"
width="600"
height="498"
srcset="https://ilolicon.github.io/p/kubernetes/icons/structure_hu12b93151174b3e04ef92f8cdd319b528_196054_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/structure_hu12b93151174b3e04ef92f8cdd319b528_196054_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="structure"
class="gallery-image"
data-flex-grow="120"
data-flex-basis="289px"
>&lt;/p>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/k8s-network-structure02.png"
width="2418"
height="1128"
srcset="https://ilolicon.github.io/p/kubernetes/icons/k8s-network-structure02_hu86518e8c49d554475a7b0c3fae4a2e9e_2485545_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/k8s-network-structure02_hu86518e8c49d554475a7b0c3fae4a2e9e_2485545_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="structure02"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a class="link" href="https://github.com/kubernetes/kubeadm" target="_blank" rel="noopener"
>kubeadm&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>master/nodes: 安装&lt;code>kubetlet&lt;/code> &lt;code>kubeadm&lt;/code> &lt;code>docker&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>master: &lt;code>kubeadm init&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># master init&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo kubeadm init &lt;span class="se">\ &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --kubernetes-version&lt;span class="o">=&lt;/span>v1.20.15 &lt;span class="se">\ &lt;/span> &lt;span class="c1"># k8s版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --pod-network-cidr&lt;span class="o">=&lt;/span>10.244.0.0/16 &lt;span class="se">\ &lt;/span> &lt;span class="c1"># pod网段&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --service-cidr&lt;span class="o">=&lt;/span>10.96.0.0/12 &lt;span class="se">\ &lt;/span> &lt;span class="c1"># service网段&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --ignore-preflight-errors&lt;span class="o">=&lt;/span>Swap &lt;span class="c1"># 忽略预检错误&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>nodes: &lt;code>kubeadm join&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># nodes join&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo kubeadm join &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> 10.211.55.57:6443 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --token hewmhd.fro3dttm001dohys &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --discovery-token-ca-cert-hash sha256:826faddde57dc07d0fbf31e7aa809eb5fc22613787a2fc8ab50f55c4e706cd45
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>Images&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">ilolicon@master:~$ sudo docker image ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">REPOSITORY TAG IMAGE ID CREATED SIZE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">k8s.gcr.io/kube-apiserver v1.20.15 3ecdeee1255c &lt;span class="m">7&lt;/span> months ago 113MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">k8s.gcr.io/kube-controller-manager v1.20.15 403106abce42 &lt;span class="m">7&lt;/span> months ago 108MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">k8s.gcr.io/kube-scheduler v1.20.15 bfc1b1725466 &lt;span class="m">7&lt;/span> months ago 44.1MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">k8s.gcr.io/kube-proxy v1.20.15 3c1b1abd329d &lt;span class="m">7&lt;/span> months ago 93.6MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">k8s.gcr.io/etcd 3.4.13-0 05b738aa1bc6 &lt;span class="m">24&lt;/span> months ago 312MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">k8s.gcr.io/coredns 1.7.0 db91994f4ee8 &lt;span class="m">2&lt;/span> years ago 42.8MB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">k8s.gcr.io/pause 3.2 2a060e2e7101 &lt;span class="m">2&lt;/span> years ago 484kB &lt;span class="c1"># 创建基础架构容器使用 为Pod提供底层基础结构 无需启动和运行&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="kuberntes资源概述">Kuberntes资源概述&lt;/h2>
&lt;ul>
&lt;li>RESTful风格API
&lt;ul>
&lt;li>GET、POST、DELETE、PUT&amp;hellip;&lt;/li>
&lt;li>kubectl run、get、expose、edit&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>资源(对象)
&lt;ul>
&lt;li>workload: Pod、ReplicaSet、Deployment、StatefulSet、DaemonSet、Job、Cronjob&amp;hellip;&lt;/li>
&lt;li>服务发现与均衡: Service、Ingress&amp;hellip;&lt;/li>
&lt;li>配置与存储: Volume、CSI&amp;hellip;
&lt;ul>
&lt;li>ConfigMap、Secret&lt;/li>
&lt;li>DownwardAPI&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>集群级资源
&lt;ul>
&lt;li>Namespace、Node、Role、ClusterRole、RoleBinding、ClusterRoleBinding&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>元数据型资源
&lt;ul>
&lt;li>HPA、PodTemplate、LimitRange&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="资源清单定义">资源清单定义&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>创建资源的方法&lt;/p>
&lt;ul>
&lt;li>
&lt;p>apiserver仅接收json格式的资源定义&lt;/p>
&lt;/li>
&lt;li>
&lt;p>yaml格式提供配置清单 apiserver可自动将其转换为json格式 而后再提交&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>大部分资源的配置清单 主要都有五个主要的部分组成&lt;/p>
&lt;ul>
&lt;li>
&lt;p>apiversion&lt;/p>
&lt;ul>
&lt;li>&lt;code>kubectl api-versions&lt;/code> # 所属API群组&lt;/li>
&lt;li>标识方式: &lt;code>group/version&lt;/code> 省略组名则为core group&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>kind: 资源类别&lt;/p>
&lt;/li>
&lt;li>
&lt;p>metadata: 元数据&lt;/p>
&lt;ul>
&lt;li>name: 同一类别中 name需要唯一&lt;/li>
&lt;li>namespace: 所属k8s的哪个名称空间&lt;/li>
&lt;li>labels&lt;/li>
&lt;li>annotations&lt;/li>
&lt;li>每个资源的引用PATH
&lt;ul>
&lt;li>&lt;code>/api/${GROUP/VERSION}/namespace/${NAMESPACE}/${TYPE}/${NAME}&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>spec(重要): 定义用户期望的状态 disired state&lt;/p>
&lt;/li>
&lt;li>
&lt;p>status: 当前状态 current state 本字段由Kubernetes集群维护&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>字段太多 可以借助&lt;code>kubectl explain --help&lt;/code>命令查看详细信息&lt;/p>
&lt;ul>
&lt;li>kubectl explain pod&lt;/li>
&lt;li>kubectl explain pod.metadata&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="pod概述">Pod概述&lt;/h3>
&lt;p>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/" target="_blank" rel="noopener"
>pods&lt;/a>&lt;/p>
&lt;h4 id="自主式pod">自主式Pod&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">pod-demo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">tier&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">frontend&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">busybox:latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">command&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;/bin/sh&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="s2">&amp;#34;sleep 3600&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="pod资源">Pod资源&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>spec.containers &amp;lt;[]object&amp;gt;&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="c"># kubectl explain pod.spec.containers&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;string&amp;gt;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">imagePullPolicy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;string&amp;gt; &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Always Never IfNotPresent&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="l">...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 修改镜像中的默认应用&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>- &lt;span class="l">command/args&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="l">https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>标签&lt;/p>
&lt;ul>
&lt;li>key = value
&lt;ul>
&lt;li>key: 字母 数字 _ - .&lt;/li>
&lt;li>value: 可以为空 只能字母或数字开头及结尾&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>标签选择器&lt;/p>
&lt;ul>
&lt;li>等值关系: =、==、!=(不等于会筛选出不具有该标签的资源)&lt;/li>
&lt;li>集合关系
&lt;ul>
&lt;li>KEY in (VALUE1,VALUE2,&amp;hellip;)&lt;/li>
&lt;li>KEY notin (VALUE1,VALUE2,&amp;hellip;)&lt;/li>
&lt;li>KEY # 存在这个KEY就行&lt;/li>
&lt;li>!KEY # 不存在此键的资源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>许多资源支持内嵌字段来使用标签选择器&lt;/p>
&lt;ul>
&lt;li>matchLabels: 直接给定键值&lt;/li>
&lt;li>matchExpressions: 基于给定的表达式来定义使用标签选择器
&lt;ul>
&lt;li>{key: &amp;ldquo;KEY&amp;rdquo;, operator: &amp;ldquo;OPERATOR&amp;rdquo;,values:[VAL1,VAL2,VAL3,&amp;hellip;]&lt;/li>
&lt;li>操作符
&lt;ul>
&lt;li>In、NotIn: values字段的值必须为非空列表&lt;/li>
&lt;li>Exists、NotExists: values字段的值必须为空列表&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>spec.nodeSelector &amp;lt;map[striong]string&amp;gt;&lt;/p>
&lt;ul>
&lt;li>节点标签选择器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>spec.nodeName &lt;code>&amp;lt;string&amp;gt;&lt;/code> # 直接指定运行node&lt;/p>
&lt;/li>
&lt;li>
&lt;p>annotations&lt;/p>
&lt;ul>
&lt;li>与label不同的地方在于 它不能用于挑选资源对象 仅用于为对象提供&lt;strong>元数据&lt;/strong>&lt;/li>
&lt;li>没有键长度/值长度限制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>spec.restartPolicy&lt;/p>
&lt;ul>
&lt;li>重启策略: One of Always, OnFailure, Never. Default to Always&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="pod生命周期">Pod生命周期&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>状态&lt;/p>
&lt;ul>
&lt;li>Pending # 调度尚未完成&lt;/li>
&lt;li>Running # 运行状态&lt;/li>
&lt;li>Failed&lt;/li>
&lt;li>Succeeded&lt;/li>
&lt;li>Unknown&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Pod生命周期中的重要行为&lt;/p>
&lt;ul>
&lt;li>初始化容器&lt;/li>
&lt;li>容器探测(自定义命令/TCP套接字发请求/HTTP应用层请求)
&lt;ul>
&lt;li>liveness probe: 探测容器是否存活&lt;/li>
&lt;li>readiness probe: 探测容器是否准备就绪 能对外提供服务&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>钩子
&lt;ul>
&lt;li>post start&lt;/li>
&lt;li>pre stop&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/pod-lifecycle.png"
width="1802"
height="918"
srcset="https://ilolicon.github.io/p/kubernetes/icons/pod-lifecycle_hu63a9e9cf93a88172974cf2b0b759da82_82884_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/pod-lifecycle_hu63a9e9cf93a88172974cf2b0b759da82_82884_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="pod-lifecycle"
class="gallery-image"
data-flex-grow="196"
data-flex-basis="471px"
>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="pod容器探针类型">Pod容器探针类型&lt;/h4>
&lt;p>&lt;code>kubectl explain pod.spec.containers.livenessProbe&lt;/code>&lt;/p>
&lt;p>&lt;code>kubectl explain pod.spec.containers.readinessProbe&lt;/code>&lt;/p>
&lt;ul>
&lt;li>exec Action&lt;/li>
&lt;li>httpGet Action&lt;/li>
&lt;li>tcpSocket Action&lt;/li>
&lt;/ul>
&lt;h4 id="pod控制器">Pod控制器&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>ReplicaSet&lt;/p>
&lt;ul>
&lt;li>Kubectl explain replicaset&lt;/li>
&lt;li>用户期望副本数 标签选择器 Pod资源模版&lt;/li>
&lt;li>不建议直接使用ReplicaSet&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">apps/v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ReplicaSet&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replicas&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">selector&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">matchLabels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">release&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">canary&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">template&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp-pod&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">app&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">release&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">canary&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">environment&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">qa&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">myapp-container&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">image&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">nginx:alpine&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">containerPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>Deployment&lt;/p>
&lt;ul>
&lt;li>构建在ReplicaSet之上 而非Pod
&lt;ul>
&lt;li>实现滚动更新(多出或少于N个副本 控制更新粒度)、回滚&lt;/li>
&lt;li>通常管理10个历史版本(ReplicaSet)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>管理无状态应用最好的控制器&lt;/li>
&lt;li>无状态(只关注群体、不关注个体)、持续运行应用&lt;/li>
&lt;li>声明式管理(即可以创建 也可以更新 &lt;code>kubectl apply -f deployment.yaml&lt;/code>)&lt;/li>
&lt;li>&lt;code>kubectl rollout history&lt;/code> 查看滚动历史&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/deployment-update.png"
width="1728"
height="566"
srcset="https://ilolicon.github.io/p/kubernetes/icons/deployment-update_hu1b11393a4a96395d8bc44f2effe78eee_1490645_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/deployment-update_hu1b11393a4a96395d8bc44f2effe78eee_1490645_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="deployment-update"
class="gallery-image"
data-flex-grow="305"
data-flex-basis="732px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>DaemonSet&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>kubectl explain deployment.spec.strategy.rollingUpdate&lt;/code> # 滚动更新策略&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确保集群中的每一个节点(或部分满足条件的节点)精确运行一个Pod副本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通常用于一些系统级的后台任务&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无状态、持续运行应用&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Job&lt;/p>
&lt;ul>
&lt;li>只做一次 只要完成就正常退出 没完成才进行重构&lt;/li>
&lt;li>执行一次性的作业&lt;/li>
&lt;li>不需要持续在后台运行 执行完成就退出&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Cronjob&lt;/p>
&lt;ul>
&lt;li>周期性Job&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>StatefulSet&lt;/p>
&lt;ul>
&lt;li>管理有状态应用&lt;/li>
&lt;li>每一个pod副本单独管理 拥有自己独有的标识和独有的数据集&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>TPR: Third Party Resources 1.2+ - 1.7&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CDE: Custom Defined Resources 1.8+&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Operator&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="service概述">Service概述&lt;/h3>
&lt;h4 id="service代理">Service代理&lt;/h4>
&lt;p>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/" target="_blank" rel="noopener"
>services-networking&lt;/a>&lt;/p>
&lt;ul>
&lt;li>userspace
&lt;ul>
&lt;li>kube-proxy会监视Kubernetes控制平面对Service对象和Endpoints对象的添加和移除操作&lt;/li>
&lt;li>对每个Service它会在本地Node上打开一个端口(随机选择) 任何连接到&lt;strong>代理端口&lt;/strong>的请求 都会被代理到Service的后端&lt;code>Pods&lt;/code>中的某个上面
&lt;ul>
&lt;li>使用哪个后端Pod是 kube-proxy 基于&lt;code>SessionAffinity&lt;/code>来确定的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>最后 它配置 iptables 规则 捕获到达该 Service 的&lt;code>clusterIP&lt;/code>(是虚拟 IP)和&lt;code>Port&lt;/code>的请求 并重定向到代理端口 代理端口再代理请求到后端Pod
&lt;ul>
&lt;li>默认情况下 用户空间模式下的kube-proxy通过轮转算法选择后端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>流量来回在内核和用户空间切换 效率较低&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/services-userspace-overview.svg"
loading="lazy"
alt="services-userspace-overview"
>&lt;/p>
&lt;ul>
&lt;li>iptables
&lt;ul>
&lt;li>
&lt;p>&lt;code>kube-proxy&lt;/code>会监视Kubernetes控制节点对Service对象和Endpoints对象的添加和移除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对每个Service 它会配置iptables规则 从而捕获到达该Service的&lt;code>clusterIP&lt;/code>和端口的请求 进而将请求重定向到 Service 的一组后端中的某个Pod上面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于每个Endpoints对象 它也会配置iptables规则 这个规则会选择一个后端组合&lt;/p>
&lt;ul>
&lt;li>默认的策略是 kube-proxy在iptables模式下随机选择一个后端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>使用iptables处理流量具有较低的系统开销 因为流量由Linux netfilter处理 而无需在用户空间和内核空间之间切换 这种方法也可能更可靠&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果kube-proxy在iptables模式下运行 并且所选的第一个 Pod 没有响应 则连接失败&lt;/p>
&lt;ul>
&lt;li>这与用户空间模式不同: 在这种情况下 kube-proxy将检测到与第一个Pod的连接已失败 并会自动使用其他后端Pod 重试&lt;/li>
&lt;li>可以使用Pod&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes" target="_blank" rel="noopener"
>就绪探测器&lt;/a> 验证后端Pod可以正常工作 以便iptables模式下的kube-proxy仅看到测试正常的后端 避免将流量通过kube-proxy发送到已知已失败的 Pod&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/services-iptables-overview.svg"
loading="lazy"
alt="services-iptables-overview"
>&lt;/p>
&lt;ul>
&lt;li>ipvs
&lt;ul>
&lt;li>
&lt;p>特性状态： Kubernetes v1.11 [stable]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在&lt;code>ipvs&lt;/code>模式下 kube-proxy监视Kubernetes服务和端点 调用&lt;code>netlink&lt;/code>接口创建相应的IPVS规则 并定期将IPVS规则与Kubernetes服务和端点同步 该控制循环可确保 IPVS 状态与所需状态匹配&lt;/p>
&lt;/li>
&lt;li>
&lt;p>访问服务时 IPVS将流量定向到后端Pod之一&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IPVS代理模式基于类似于iptables模式的netfilter挂钩函数 但是使用哈希表作为基础数据结构 并且在内核空间中工作&lt;/p>
&lt;ul>
&lt;li>这意味着 与iptables模式下的kube-proxy相比 IPVS模式下的kube-proxy重定向通信的延迟要短 并且在同步代理规则时具有更好的性能&lt;/li>
&lt;li>与其他代理模式相比 IPVS模式还支持更高的网络流量吞吐量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>IPVS提供了更多选项来平衡后端Pod的流量&lt;/p>
&lt;ul>
&lt;li>&lt;code>rr&lt;/code>: 轮询(Round-Robin)&lt;/li>
&lt;li>&lt;code>lc&lt;/code>: 最少链接(Least Connection) 即打开链接数量最少者优先&lt;/li>
&lt;li>&lt;code>dh&lt;/code>: 目标地址哈希(Destination Hashing)&lt;/li>
&lt;li>&lt;code>sh&lt;/code>: 源地址哈希(Source Hashing)&lt;/li>
&lt;li>&lt;code>sed&lt;/code>: 最短预期延迟(Shortest Expected Delay)&lt;/li>
&lt;li>&lt;code>nq&lt;/code>: 从不排队(Never Queue)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>备注&lt;/p>
&lt;ul>
&lt;li>要在IPVS模式下运行kube-proxy必须在启动kube-proxy之前使IPVS在节点上可用&lt;/li>
&lt;li>当kube-proxy以IPVS代理模式启动时 它将验证IPVS内核模块是否可用
&lt;ul>
&lt;li>如果未检测到IPVS内核模块 则kube-proxy将退回到以iptables代理模式运行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/services-ipvs-overview.svg"
loading="lazy"
alt="services-ipvs-overview"
>&lt;/p>
&lt;h4 id="service类型">Service类型&lt;/h4>
&lt;ul>
&lt;li>ClusterIP: 通过集群的内部IP暴露服务 选择该值时服务只能够在集群内部访问 这也是默认的&lt;code>ServiceType&lt;/code>&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport" target="_blank" rel="noopener"
>NodePort&lt;/a>: 通过每个节点上的IP和静态端口(NodePort)暴露服务 NodePort服务会路由到自动创建的ClusterIP服务
&lt;ul>
&lt;li>通过请求 &lt;code>&amp;lt;节点IP&amp;gt;:&amp;lt;节点端口&amp;gt;&lt;/code> 你可以从集群的外部访问一个NodePort服务&lt;/li>
&lt;li>Client -&amp;gt; NodeIP:NodePort -&amp;gt; ClusterIP:ServicePort -&amp;gt; PodIP:containerPort&lt;/li>
&lt;li>为避免单Node压力过大 会在外面再加一层负载均衡
&lt;ul>
&lt;li>公有云环境: LBaaS(参考下面LoadBalancer类型)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer" target="_blank" rel="noopener"
>LoadBalancer&lt;/a>: 使用云提供商的负载均衡器向外部暴露服务 外部负载均衡器可以将流量路由到自动创建的NodePort服务和ClusterIP服务上&lt;/li>
&lt;li>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#externalname" target="_blank" rel="noopener"
>ExternalName&lt;/a>: 通过返回CNAME和对应值 可以将服务映射到externalName字段的内容(例如&lt;code>foo.bar.example.com&lt;/code>) 无需创建任何类型代理
&lt;ul>
&lt;li>FQDN(CoreDNS 内部解析)
&lt;ul>
&lt;li>CNAME -&amp;gt; FQDN(外部真正的FQDN )&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="headless-services无头service">Headless Services(无头Service)&lt;/h4>
&lt;ul>
&lt;li>有时不需要或不想要负载均衡 以及单独的Service IP 遇到这种情况 可以通过指定Cluster IP(&lt;code>spec.clusterIP&lt;/code>)的值为 &lt;code>&amp;quot;None&amp;quot;&lt;/code>来创建 &lt;code>Headless&lt;/code> Service&lt;/li>
&lt;li>你可以使用一个无头Service与其他服务发现机制进行接口 而不必与Kubernetes的实现捆绑在一起&lt;/li>
&lt;li>对于无头&lt;code>Services&lt;/code>并不会分配Cluster IP kube-proxy不会处理它们 而且平台也不会为它们进行负载均衡和路由 DNS如何实现自动配置 依赖于Service是否定义了选择算符&lt;/li>
&lt;/ul>
&lt;h3 id="ingress">Ingress&lt;/h3>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/ingress-flow.png"
width="1182"
height="886"
srcset="https://ilolicon.github.io/p/kubernetes/icons/ingress-flow_hu9c99a0266fa357bab5ac86316de97a76_1018969_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/ingress-flow_hu9c99a0266fa357bab5ac86316de97a76_1018969_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ingress-flow"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener"
>ingress&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Service对后端特定类型Pod分类(label selector)&lt;/li>
&lt;li>Ingress基于上面的分类识别后端Pod 并生成配置信息注入到nginx(需要重载配置)/envoy/traefik等&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/" target="_blank" rel="noopener"
>ingress-controllers&lt;/a>&lt;/p>
&lt;h3 id="存储卷">存储卷&lt;/h3>
&lt;p>&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/concepts/storage/" target="_blank" rel="noopener"
>kubernetes-storage&lt;/a>&lt;/p>
&lt;p>&lt;code>kubectl explain pods.spec.volumes&lt;/code>&lt;/p>
&lt;ul>
&lt;li>emptyDir # 临时目录 随pod删除而消失(生命周期同pod)
&lt;ul>
&lt;li>gitRepo(clone到机器 修改不会同步 需要同步可以自己再做一个sidecar)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>hostPath # 宿主机路径&lt;/li>
&lt;li>SAN(iSCSI&amp;hellip;)、NAS(nfs、cifs&amp;hellip;)&lt;/li>
&lt;li>分布式存储
&lt;ul>
&lt;li>glusterfs、rdb、cephfs&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>云存储
&lt;ul>
&lt;li>EBS、Azure Disk&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="pvpvc">PV/PVC&lt;/h4>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/pvc.png"
width="2068"
height="1350"
srcset="https://ilolicon.github.io/p/kubernetes/icons/pvc_hufc33b2495877c5db5264e9558db08b3f_2577789_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/pvc_hufc33b2495877c5db5264e9558db08b3f_2577789_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="pvc"
class="gallery-image"
data-flex-grow="153"
data-flex-basis="367px"
>&lt;/p>
&lt;h4 id="storageclass">StorageClass&lt;/h4>
&lt;ul>
&lt;li>存储设备需支持RESTful风格的创建请求&lt;/li>
&lt;li>根据请求动态创建PV&lt;/li>
&lt;/ul>
&lt;h4 id="configmap">ConfigMap&lt;/h4>
&lt;ul>
&lt;li>ConfigMap是一种 API 对象 用来将非机密性的数据保存到键值对中&lt;/li>
&lt;li>使用时&lt;a class="link" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener"
>Pods&lt;/a>可以将其用作环境变量、命令行参数或者存储卷中的配置文件&lt;/li>
&lt;li>ConfigMap将你的环境配置信息和&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-image" target="_blank" rel="noopener"
>容器镜像&lt;/a>解耦 便于应用配置的修改&lt;/li>
&lt;/ul>
&lt;h5 id="容器化配置应用方式">容器化配置应用方式&lt;/h5>
&lt;ul>
&lt;li>自定义命令行参数
&lt;ul>
&lt;li>args: []&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>把配置文件直接打包至镜像&lt;/li>
&lt;li>环境变量
&lt;ul>
&lt;li>CloudNative的应用程序一般可直接通过环境变量加载配置&lt;/li>
&lt;li>通过entrypoint脚本来预处理变量为配置文件中的配置信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>存储卷&lt;/li>
&lt;/ul>
&lt;h4 id="secret">Secret&lt;/h4>
&lt;ul>
&lt;li>Secret是一种包含少量敏感信息例如密码、令牌或密钥的对象 这样的信息可能会被放在&lt;a class="link" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener"
>Pod&lt;/a>规约中或者镜像中&lt;/li>
&lt;li>使用Secret意味着你不需要在应用程序代码中包含机密数据&lt;/li>
&lt;li>Secret类似于&lt;a class="link" href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/" target="_blank" rel="noopener"
>ConfigMap&lt;/a>但专门用于保存敏感数据&lt;/li>
&lt;/ul>
&lt;h2 id="statefulset控制器">StatefulSet控制器&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>CoreOS Operator&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cattle/pet # 一个关注群体 一个关注个体(和无状态应用的区别)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PetSet(1.3) -&amp;gt; StatefulSet(1.5+)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>StatefulSet主要用于管理有以下特性的应用程序&lt;/p>
&lt;ul>
&lt;li>稳定且唯一的网络标识符&lt;/li>
&lt;li>稳定且持久的存储&lt;/li>
&lt;li>有序、平滑的部署和扩展&lt;/li>
&lt;li>有序、平滑的终止和删除&lt;/li>
&lt;li>有序的滚动更新&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>一般来说 一个典型的StatefulSet由三个组件组成&lt;/p>
&lt;ul>
&lt;li>handless service # 无头服务 确保名称唯一&lt;/li>
&lt;li>StatefulSet # 控制器&lt;/li>
&lt;li>volumeClaimTemplate # 存储卷申请模版(不能使用同一存储卷 pod模版创建的存储卷都是一样的 所以需要卷申请模版)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>kubelet explain sts.spec.updateStrategy.rollingUpdate&lt;/code>&lt;/p>
&lt;ul>
&lt;li>partition &amp;lt;inter&amp;gt; # 控制更新的Pod&lt;/li>
&lt;li>partition: N # 大于等于编号N的Pod将被更新 默认值: 0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="认证及serviceaccount">认证及ServiceAccount&lt;/h2>
&lt;h3 id="认证授权">认证授权&lt;/h3>
&lt;ul>
&lt;li>认证(支持多种认证方式) # 认证插件
&lt;ul>
&lt;li>令牌认证 bearer token&lt;/li>
&lt;li>ssl认证(确认服务端/客户端身份) 双向证书认证(https)&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>授权检查(权限) # 授权插件
&lt;ul>
&lt;li>RBAC # kubeadm部署的集群强制开启RBAC&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>准入控制(关联的其他资源或操作 是否有权限 进一步补充授权机制)&lt;/li>
&lt;li>API Server需要信息去识别客户端的操作
&lt;ul>
&lt;li>user: username + uid&lt;/li>
&lt;li>group&lt;/li>
&lt;li>extra&lt;/li>
&lt;li>API(请求的Kubernetes API)
&lt;ul>
&lt;li>Request Path
&lt;ul>
&lt;li>&lt;code>kubectl proxy --port=8080&lt;/code>&lt;/li>
&lt;li>&lt;code>curl http://localhost:8080/api/v1/namespaces&lt;/code>&lt;/li>
&lt;li>&lt;code>curl http://localhost:8080/apis/apps/v1/namespaces/default/deployments/myapp-deploy/&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>HTTP request verb
&lt;ul>
&lt;li>GET POST PUT DELETE&lt;/li>
&lt;li>get list create update patch watch proxy redirect delete deletecollection&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Resources&lt;/li>
&lt;li>SubResources&lt;/li>
&lt;li>Namespace&lt;/li>
&lt;li>API Group&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="serviceaccount">ServiceAccount&lt;/h3>
&lt;ul>
&lt;li>访问APIServer的两种客户端
&lt;ul>
&lt;li>kubectl/dashborad 集群外部客户端(userAccount)&lt;/li>
&lt;li>pod 集群内部客户端(serviceAccount)
&lt;ul>
&lt;li>&lt;code>kubectl explain pods.spec.serviceAccountName&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>kubeconfig
&lt;ul>
&lt;li>&lt;code>kubectl config view&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="rbac授权">RBAC授权&lt;/h3>
&lt;ul>
&lt;li>授权插件
&lt;ul>
&lt;li>Node&lt;/li>
&lt;li>ABAC(&lt;em>Attribute-based access control&lt;/em>)&lt;/li>
&lt;li>RBAC(&lt;em>Role-based access contro&lt;/em>)&lt;/li>
&lt;li>Webhook&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/k8s-RBAC.png"
width="1364"
height="768"
srcset="https://ilolicon.github.io/p/kubernetes/icons/k8s-RBAC_hu93382d84de46ca6bdd4d6c35df8f4890_1483186_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/k8s-RBAC_hu93382d84de46ca6bdd4d6c35df8f4890_1483186_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="k8s-RBAC"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;ul>
&lt;li>K8S-RBAC
&lt;ul>
&lt;li>role
&lt;ul>
&lt;li>operations&lt;/li>
&lt;li>objects&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>rolebinding
&lt;ul>
&lt;li>user account OR service account&lt;/li>
&lt;li>role&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>kubectl create role pods-reader --verb=get,list,watch --resource=pods --dry-run -o yaml&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/kubernetes/icons/role-binding.png"
width="1498"
height="1096"
srcset="https://ilolicon.github.io/p/kubernetes/icons/role-binding_hue49744d6898b8c4106d004f8692e3f91_1070895_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/kubernetes/icons/role-binding_hue49744d6898b8c4106d004f8692e3f91_1070895_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="role-binding"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="328px"
>&lt;/p>
&lt;h2 id="helm">Helm&lt;/h2>
&lt;ul>
&lt;li>类似yum&lt;/li>
&lt;/ul>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>ubuntu&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://askubuntu.com/questions/428772/how-to-install-specific-version-of-some-package/428778#428778?newreg=d056242a7a0340598dd1d2d4fad63e81" target="_blank" rel="noopener"
>apt install speciffic version&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.serverlab.ca/tutorials/containers/docker/how-to-set-the-proxy-for-docker-on-ubuntu/" target="_blank" rel="noopener"
>set-proxy-on-ubuntu-docker&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://askubuntu.com/questions/2493/apt-get-or-aptitude-equivalent-to-yum-whatprovides" target="_blank" rel="noopener"
>apt-get-like-yum-whatprovides&lt;/a>&lt;/p>
&lt;ul>
&lt;li>kubetnetes&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/63136175/kubectl-get-componentstatus-shows-unhealthy" target="_blank" rel="noopener"
>kubectl-get-commponentstatus-shows-unhealthy&lt;/a>&lt;/p></description></item><item><title>Prometheus</title><link>https://ilolicon.github.io/p/prometheus/</link><pubDate>Thu, 10 Dec 2020 21:36:00 +0800</pubDate><guid>https://ilolicon.github.io/p/prometheus/</guid><description>&lt;h2 id="prometheus监控系统">Prometheus监控系统&lt;/h2>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/introduction/overview/" target="_blank" rel="noopener"
>&lt;img src="https://img.shields.io/badge/prometheus-v2.x&amp;#43;-E44F34"
loading="lazy"
alt="prometheus"
>&lt;/a>&lt;/p>
&lt;p>不稳定才是系统的恒态 稳定只是其中的一种特殊表现形式&lt;/p>
&lt;h2 id="监控系统的基础概念">监控系统的基础概念&lt;/h2>
&lt;h3 id="监控系统组件">监控系统组件&lt;/h3>
&lt;ul>
&lt;li>指标数据的采集(抓取)&lt;/li>
&lt;li>指标数据存储
&lt;ul>
&lt;li>存储持续写入性能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>指标数据趋势分析及可视化
&lt;ul>
&lt;li>分析、预测&lt;/li>
&lt;li>界面展示、直观查看
&lt;ul>
&lt;li>Zabbix自带&lt;/li>
&lt;li>Open-Falcon/夜莺&amp;hellip;&lt;/li>
&lt;li>通用的前台界面 如: Grafana&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>告警
&lt;ul>
&lt;li>基础、核心功能之一&lt;/li>
&lt;li>表达式 -〉媒介(钉钉、微信、邮件&amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="监控体系自底向上">监控体系(自底向上)&lt;/h3>
&lt;ul>
&lt;li>系统层监控(关键指标)
&lt;ul>
&lt;li>系统监控
&lt;ul>
&lt;li>CPU&lt;/li>
&lt;li>Load&lt;/li>
&lt;li>Memory&lt;/li>
&lt;li>Swap&lt;/li>
&lt;li>DiskIO&lt;/li>
&lt;li>Processes&lt;/li>
&lt;li>Kernel Parameters&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>网络监控
&lt;ul>
&lt;li>网络设备&lt;/li>
&lt;li>工作负载&lt;/li>
&lt;li>网络延迟&lt;/li>
&lt;li>丢包率&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>中间件及基础设施类系统监控
&lt;ul>
&lt;li>消息中间件: Kafka、RocketMQ、RabbitMQ等&lt;/li>
&lt;li>Web服务容器: Tomcat、Jetty等&lt;/li>
&lt;li>数据库及缓存系统: MySQL、PostgreSQL、MongoDB、ElasticSearch、Redis等&lt;/li>
&lt;li>存储系统: Ceph等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>应用层监控
&lt;ul>
&lt;li>用于衡量应用程序代码的状态和性能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>业务层监控
&lt;ul>
&lt;li>用于衡量应用程序的价值(销售指标等)&lt;/li>
&lt;li>QPS、DAU日活、转化率&lt;/li>
&lt;li>业务接口: 登陆数、注册数、订单量、支付量、搜索量等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="云原生时代的可观测性">云原生时代的可观测性&lt;/h3>
&lt;p>&lt;a class="link" href="https://landscape.cncf.io/" target="_blank" rel="noopener"
>&lt;img src="https://img.shields.io/badge/Landscape-Guide-1081c2"
loading="lazy"
alt="CNCF Cloud Native Interactive Landscape"
>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可观测性系统&lt;/p>
&lt;ul>
&lt;li>指标监控(Metrics): 随时间推移产生的一些与监控相关的可聚合数据点&lt;/li>
&lt;li>日志监控(Logging): 离散式的日志或事件(&lt;code>结构化&lt;/code>)&lt;/li>
&lt;li>链路跟踪(Tracing): 分布式应用调用链跟踪(调用时长/性能)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CNCF将&lt;code>可观测性&lt;/code>和&lt;code>数据分析&lt;/code>归类为一个单独的类别 划分成了5个子类&lt;/p>
&lt;ul>
&lt;li>监控系统&lt;/li>
&lt;li>日志系统&lt;/li>
&lt;li>分布式调用链跟踪系统&lt;/li>
&lt;li>混沌工程系统: 结合监控系统提前发现问题&lt;/li>
&lt;li>持续优化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Prometheus仅仅是可观测性中的一个纬度(指标监控)中的一个代表&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="著名的监控方法论">著名的监控方法论&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Google的四个黄金指标&lt;/p>
&lt;ul>
&lt;li>常用于在服务级别帮助衡量终端用户体验、服务中断、业务影响等层面的问题&lt;/li>
&lt;li>适用于应用及服务监控&lt;/li>
&lt;li>四个黄金指标
&lt;ul>
&lt;li>延迟(Latency)
&lt;ul>
&lt;li>服务请求所需要的时长 如: HTTP请求平均延迟&lt;/li>
&lt;li>需要区分失败请求和成功请求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>流量(Traffic)
&lt;ul>
&lt;li>衡量服务的容量需求 如: 每秒处理的HTTP1请求数 数据库系统的事务数量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>错误(Errors)
&lt;ul>
&lt;li>请求失败的速率 用于衡量错误发生的情况&lt;/li>
&lt;li>显示失败(HTTP500) 隐式失败(返回错误内容/无效内容) 策略原因导致的失败(响应时间超过30ms请求视为失败)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>饱和度(Saturation): 服务受限资源
&lt;ul>
&lt;li>衡量资源的使用情况 用于表达程序有多&lt;strong>满&lt;/strong>&lt;/li>
&lt;li>如: CPU 内存 I/O 磁盘等资源的使用情况(NodeExporter)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Netflix的USE方法&lt;/p>
&lt;ul>
&lt;li>主要用于分析系统性能问题 指导用户快速识别资源瓶颈以及错误的方法&lt;/li>
&lt;li>应用于主机指标监控&lt;/li>
&lt;li>USE
&lt;ul>
&lt;li>使用率(Utilization)
&lt;ul>
&lt;li>关注资源的使用情况 主要包括但不限于CPU 内存 网络 磁盘等&lt;/li>
&lt;li>100%的使用率通常是系统性能瓶颈的标志&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>饱和度(Saturation)
&lt;ul>
&lt;li>如CPU的平均运行排队长度&lt;/li>
&lt;li>任何资源在某种程度上的饱和都可能导致系统性能的下降&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>错误(Error)
&lt;ul>
&lt;li>错误计数&lt;/li>
&lt;li>如: 网卡在数据包传输过程中检测到的以太网网络冲突了14次&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Weave Cloud的RED方法&lt;/p>
&lt;ul>
&lt;li>Weave Cloud基于Google的四个黄金指标的原则下 结合Prometheus以及Kubernetes容器实践 细化和总结的方法论 特别适合云原生应用以及微服务架构应用的监控和度量&lt;/li>
&lt;li>在四大黄金指标的原则下 RED方法可以有效的帮助用户衡量云原生以及微服务应用下的用户体验问题&lt;/li>
&lt;li>RED方法主要关注以下三种指标
&lt;ul>
&lt;li>(Request)Rate: 每秒钟接收的请求数&lt;/li>
&lt;li>(Request)Errors: 每秒失败的请求数&lt;/li>
&lt;li>(Request)Duration: 每个请求所花费的时长&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="prometheus入门">Prometheus入门&lt;/h2>
&lt;h3 id="what-is-prometheus-monitoring">What is Prometheus Monitoring&lt;/h3>
&lt;ul>
&lt;li>Prometheus是一个&lt;strong>时序(Time Series)数据库&lt;/strong> 但它的功能却并非止步于TSDB 而是一款设计用于进行目标(&lt;strong>Target&lt;/strong>)监控的关键组件&lt;/li>
&lt;li>结合其生态内的其他组件 如: Pushgateway Alertmanager Grafana等 可构成一个完整的IT监控系统&lt;/li>
&lt;/ul>
&lt;h3 id="时序数据简介">时序数据简介&lt;/h3>
&lt;ul>
&lt;li>时序数据是在一段时间内通过重复测量(measurement)而获得的观测值的集合&lt;/li>
&lt;li>将这些观测值绘制于图形之上 它会有一个数据轴和一个&lt;strong>时间轴&lt;/strong>&lt;/li>
&lt;li>服务器指标数据、应用程序性能监控数据、网络数据等也都是时序数据&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/time-series.jpeg"
width="1080"
height="527"
srcset="https://ilolicon.github.io/p/prometheus/icons/time-series_hu803ead4c5eed63ad2ab2a959a20373a2_57351_480x0_resize_q75_box.jpeg 480w, https://ilolicon.github.io/p/prometheus/icons/time-series_hu803ead4c5eed63ad2ab2a959a20373a2_57351_1024x0_resize_q75_box.jpeg 1024w"
loading="lazy"
alt="time-series"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;h3 id="what-does-prometheus-do">What does Prometheus do&lt;/h3>
&lt;ul>
&lt;li>基于HTTP call 从配置文件中指定的网络端点(Endpoint)上周期性获取指标数据&lt;/li>
&lt;li>最简单的逻辑如下图&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/what-does-prometheus-do.png"
width="1245"
height="742"
srcset="https://ilolicon.github.io/p/prometheus/icons/what-does-prometheus-do_hub489a8c721d86275837a2f750a47c779_104121_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/what-does-prometheus-do_hub489a8c721d86275837a2f750a47c779_104121_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="what-does-prometheus-do"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="402px"
>&lt;/p>
&lt;h3 id="how-does-prometheus-work">How does Prometheus work&lt;/h3>
&lt;ul>
&lt;li>Prometheus支持通过三种类型的途径从目标上&lt;strong>抓取(Scrape)&lt;/strong> 指标数据
&lt;ul>
&lt;li>Exporters&lt;/li>
&lt;li>Instrumentation(测量系统 内建Prometheus兼容的指标暴露器)&lt;/li>
&lt;li>Pushgateway(短生命周期任务 启动/结束时间不确定)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/how-does-prometheus-work.png"
width="2597"
height="871"
srcset="https://ilolicon.github.io/p/prometheus/icons/how-does-prometheus-work_hub4766337ce40094104e377621e3497f3_326572_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/how-does-prometheus-work_hub4766337ce40094104e377621e3497f3_326572_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="how-does-prometheus-work"
class="gallery-image"
data-flex-grow="298"
data-flex-basis="715px"
>&lt;/p>
&lt;h4 id="instrumentation程序仪表">Instrumentation(程序仪表)&lt;/h4>
&lt;ul>
&lt;li>任何能够支持Scrape指标数据的应用程序都首先要具有一个测量系统&lt;/li>
&lt;li>在Prometheus的语境中 Instrumentation是指附加到应用程序中的那些用于暴露程序指标数据的客户端库
&lt;ul>
&lt;li>程序员借助于这些客户端库编写代码生成可暴露的指标数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="exporters">Exporters&lt;/h4>
&lt;ul>
&lt;li>对于那些未内建Instrumentation 且也不便于自行添加该类组件以暴露指标数据的应用程序来说 常用的办法是于待监控的目标应用程序外部运行u一个独立指标暴露程序 该类型的程序即统称为Exporter&lt;/li>
&lt;li>换句话说 Exporter负责从目标应用程序上采集和聚合原始格式的数据 并转换或聚合为Prometheus格式的指标向外暴露&lt;/li>
&lt;li>Prometheus站点上提供了大量的Exporter&lt;/li>
&lt;/ul>
&lt;h3 id="pull-and-push">Pull and Push&lt;/h3>
&lt;ul>
&lt;li>Prometheus同其它TSDB相比有一个非常典型的特征: 它主动从各Targers上&lt;strong>拉取(pull)&lt;/strong> 数据 而非等待被监控端的&lt;strong>推送(Push)&lt;/strong>&lt;/li>
&lt;li>两种方式各有优劣 其中 Pull模型的优势在于:
&lt;ul>
&lt;li>集中控制: 有利于将配置集中在Prometheus Server上完成 包括指标及采集速率等&lt;/li>
&lt;li>Prometheus的根本目标在于收集在Target上预先完成聚合的聚合型数据 而非一款由事件驱动的存储系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/pull-and-push.png"
width="1536"
height="661"
srcset="https://ilolicon.github.io/p/prometheus/icons/pull-and-push_hube57fa93b878f45a37f96cb33c551b1b_152686_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/pull-and-push_hube57fa93b878f45a37f96cb33c551b1b_152686_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="pull-and-push"
class="gallery-image"
data-flex-grow="232"
data-flex-basis="557px"
>&lt;/p>
&lt;h3 id="prometheus的生态组件">Prometheus的生态组件&lt;/h3>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/introduction/overview/#architecture" target="_blank" rel="noopener"
>promtheus-architecture&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Prometheus负责时序型指标数据的采集及存储 但数据的分析/聚合及直观展示以及告警等功能并非由Prometheus Server负责&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/prometheus-architecture.png"
width="1351"
height="811"
srcset="https://ilolicon.github.io/p/prometheus/icons/prometheus-architecture_hud5ed5663cc35a882862e3f8b09e662f5_96834_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/prometheus-architecture_hud5ed5663cc35a882862e3f8b09e662f5_96834_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="prometheus-architecture"
class="gallery-image"
data-flex-grow="166"
data-flex-basis="399px"
>
&lt;img src="https://ilolicon.github.io/p/prometheus/icons/prometheus-architecture02.png"
width="1384"
height="770"
srcset="https://ilolicon.github.io/p/prometheus/icons/prometheus-architecture02_hu517680818b655c8b14baad5fcace8e58_70580_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/prometheus-architecture02_hu517680818b655c8b14baad5fcace8e58_70580_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="prometheus-architecture"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="431px"
>&lt;/p>
&lt;ul>
&lt;li>Prometheus生态包含多个组件 其中部分组件可选
&lt;ul>
&lt;li>Prometheus Server: 收集和存储时间序列数据 Prometheus监控系统的核心组件&lt;/li>
&lt;li>Client Library: 客户端库 目的在于为那些期望原生提供Instrumentation功能的应用程序提供便捷的开发途径&lt;/li>
&lt;li>Push Gateway: 接收那些通常由短期作业生成的指标数据的网关 并支持由Prometheus Server进行指标拉取操作&lt;/li>
&lt;li>Exporters: 用于暴露现有应用程序或服务(不支持Instrumentation)的指标给Prometheus Server
&lt;ul>
&lt;li>node_exporter&lt;/li>
&lt;li>blackbox_exporter&lt;/li>
&lt;li>mysql_exporter&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Alertmanager: 从Prometheus Server接收到&lt;strong>告警通知&lt;/strong>后 通过&lt;strong>去重 分组 路由&lt;/strong>等预处理功能后以高效向用户完成告警信息的发送&lt;/li>
&lt;li>Data Visualization: Prometheus Web UI(内建 PromQL表达式浏览器) 及Grafana等&lt;/li>
&lt;li>Service Discovery: 动态发现待监控的Target 从而完成监控配置的重要组件 在容器化环境尤为有用 该组件目前由Prometheus Server内建支持&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="prometheus数据模型data-model">Prometheus数据模型(Data Model)&lt;/h3>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/concepts/data_model/" target="_blank" rel="noopener"
>prometheus-data-model&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Prometheus仅用于以&lt;strong>键值&lt;/strong>形式存储时序式的聚合数据 它并不支持存储文本信息
&lt;ul>
&lt;li>其中的&lt;strong>键&lt;/strong>称为指标(Metric) 它通常意味着CPU速率 内存使用率或分区空闲比例等&lt;/li>
&lt;li>同一指标可能为适配到多个目标或设备 因而他使用&lt;strong>标签&lt;/strong>作为元数据 从而为Metric添加更多的信息描述维度&lt;/li>
&lt;li>这些标签还可以作为过滤器进行指标过滤及聚合运算&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/data-model.png"
width="1568"
height="864"
srcset="https://ilolicon.github.io/p/prometheus/icons/data-model_hue36357c6ee0242aeedb3cc345d25fca5_258933_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/data-model_hue36357c6ee0242aeedb3cc345d25fca5_258933_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="data-model"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;h3 id="指标类型metric-types">指标类型(Metric Types)&lt;/h3>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/concepts/metric_types/" target="_blank" rel="noopener"
>prometheus-metric-types&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Prometheus使用4种方法来描述监控的指标
&lt;ul>
&lt;li>Counter: &lt;strong>计数器&lt;/strong> 用于保存单调递增型的数据 例如: 站点访问次数等 不能为负值 也不支持减少 但可以重置回0&lt;/li>
&lt;li>Gauge: &lt;strong>仪表盘&lt;/strong> 用于存储有着起伏特征的指标数据 例如: 内存使用情况等
&lt;ul>
&lt;li>Gauge是Counter的超集 但存在指标数据丢失的可能性&lt;/li>
&lt;li>Counter能让用户确切了解指标随的变化状态 而Gauge则可能随时间流逝而精准度越来越低&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Histogram: &lt;strong>直方图&lt;/strong> 它会在一段时间范围内对数据进行采样 并将其计入可配置的bucket中 Histigram能够存储更多的信息 包括样本值分布在每个bucket中的数量、所有样本值之和以及总的样本数量 从而Prometheus能够使用内置的函数进行如下操作:
&lt;ul>
&lt;li>计算样本平均值: 以值的总和除以值的数量&lt;/li>
&lt;li>计算样本分为值: 分为数有助于了解符合特定标准的数据个数 如: 评估响应时长超过1s的请求比例 若超过20%即发送告警等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Summary: &lt;strong>摘要&lt;/strong> Histogram的扩展类型 但它是直接由被检测端自行聚合计算出分位数 并将计算结果响应给Prometheus Server的样本采集请求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="作业job和实例instance">作业(Job)和实例(Instance)&lt;/h3>
&lt;ul>
&lt;li>Instance: 能够接收Prometheus Server数据Scrape操作的每个网络网络端点(endpoint) 即为一个Instance(实例)&lt;/li>
&lt;li>通常 具有类似功能的Instance的集合称为一个Job 如: 一个MySQL主从复制集群中的所有MySQL进程&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/job-and-instance.png"
width="1516"
height="1032"
srcset="https://ilolicon.github.io/p/prometheus/icons/job-and-instance_hu3d14bf3115f84bc9a808d837dc7d9195_374030_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/job-and-instance_hu3d14bf3115f84bc9a808d837dc7d9195_374030_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="job-and-instance"
class="gallery-image"
data-flex-grow="146"
data-flex-basis="352px"
>&lt;/p>
&lt;h3 id="promtheus-query-language">Promtheus Query Language&lt;/h3>
&lt;ul>
&lt;li>Prometheus提供了内置的数据查询语言PromQL(Prometheus Query Language) 支持用户进行实时的数据查询及聚合操作&lt;/li>
&lt;li>PromQL支持处理两种&lt;strong>向量&lt;/strong> 并内置提供了一组用于数据处理的&lt;strong>函数&lt;/strong>
&lt;ul>
&lt;li>即时向量: 最近一次的时间戳上跟踪的数据指标&lt;/li>
&lt;li>时间范围向量: 指定时间范围内的所有时间戳上的数据指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/promQL.png"
width="1908"
height="900"
srcset="https://ilolicon.github.io/p/prometheus/icons/promQL_hu9865fd29d613e82258402b1703bbdf83_417488_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/promQL_hu9865fd29d613e82258402b1703bbdf83_417488_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="promQL"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="508px"
>&lt;/p>
&lt;h3 id="alerts">Alerts&lt;/h3>
&lt;ul>
&lt;li>抓取到异常值后 Prometheus支持通过&lt;strong>告警(Alert)&lt;/strong> 机制向用户发送反馈或警示 会触发用户能够及时采取应对措施&lt;/li>
&lt;li>Prometheus Server仅负责生成告警指示 具体的告警行为由另一个独立的应用程序&lt;strong>Alertmanager&lt;/strong>负责
&lt;ul>
&lt;li>告警指示由Prometheus Server基于用户提供的&lt;strong>告警规则&lt;/strong> 周期性计算生成&lt;/li>
&lt;li>Alertmanager接收到Prometheus Server发来的告警指示后 基于用户定义的**告警路由(route)&lt;strong>向告警&lt;/strong>接收人(reveivers)**发送告警信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="prometheus局限性">Prometheus局限性&lt;/h3>
&lt;ul>
&lt;li>Prometheus是一款指标监控系统 不适合存储事件及日志等 它更多展示的是趋势性的监控 而非精准数据&lt;/li>
&lt;li>Prometheus认为只有最近的监控数据才有查询的需要 其本地存储的设计初衷只是保存短期(如一个月)数据 因而不支持针对大量的历史数据进行存储
&lt;ul>
&lt;li>若需要存储长期的历史数据 建议基于远程存储机制将数据保存于InfluxDB或OpenTSDB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Prometheus的集群机制成熟度不高&lt;/li>
&lt;/ul>
&lt;h2 id="运行prometheus">运行Prometheus&lt;/h2>
&lt;p>&lt;a class="link" href="https://packagecloud.io/prometheus-rpm/release/install#bash-rpm" target="_blank" rel="noopener"
>rpm-repo&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CPU使用率&lt;/p>
&lt;ul>
&lt;li>每台主机CPU在5分钟内的平均使用率&lt;/li>
&lt;li>&lt;code>(1 - avg(irate(node_cpu_second_total{mode=&amp;quot;idle&amp;quot;}[5m])) by (instance)) * 100&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CPU饱和度&lt;/p>
&lt;ul>
&lt;li>跟踪CPU的平均负载就能获取到相关主机的CPU1饱和度 实际上 它是将主机上的CPU数量考虑在内的一段时间内的平均运行队列长度&lt;/li>
&lt;li>平均负载少于CPU的数量是正常情况 而长时间内超过CPU数量则表示CPU毅然饱和&lt;/li>
&lt;li>&lt;code>node_load1 &amp;gt; on(instance) 2 * count(node_cpu_seconds_total{mode=&amp;quot;idle&amp;quot;}) by (instance)&lt;/code>
&lt;ul>
&lt;li>查询1分钟平均负载超过主机CPU数量两倍的时间序列&lt;/li>
&lt;li>CPU瓶颈、程序BUG&lt;/li>
&lt;li>控制平面&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>内存使用率&lt;/p>
&lt;ul>
&lt;li>node_exporter暴露了多个以node_memory为前缀的指标 我们重点关注下面几个
&lt;ul>
&lt;li>&lt;code>node_memory_MemTotal_bytes&lt;/code>&lt;/li>
&lt;li>&lt;code>node_memory_MemFree_bytes&lt;/code>&lt;/li>
&lt;li>&lt;code>node_memory_Buffers_bytes&lt;/code>&lt;/li>
&lt;li>&lt;code>node_memory_Cached_bytes&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>计算使用率
&lt;ul>
&lt;li>可用空间: 上面后三个指标之和&lt;/li>
&lt;li>已用空间: 总空间减去可用空间&lt;/li>
&lt;li>实用率: 已用空间除以总空间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="exporter">Exporter&lt;/h2>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/instrumenting/exporters/#exporters-and-integrations" target="_blank" rel="noopener"
>exporters-and-integrans&lt;/a>&lt;/p>
&lt;ul>
&lt;li>node_exporter&lt;/li>
&lt;li>blackbox_exporter&lt;/li>
&lt;li>mysql_exporter&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h3 id="客户端库">客户端库&lt;/h3>
&lt;ul>
&lt;li>应用程序自己并不会直接生成指标数据 这依赖于开发人员将相关的客户端库添加至应用程序中构建出的测量系统(instrumentation system)来完成
&lt;ul>
&lt;li>官方库语言支持: Go、Python、Java(或Scala)和Ruby&lt;/li>
&lt;li>第三方库语言支持: Bash(pushgateway)、C、C++、C#、Node.js、Haskell、Erlang、Perl、PHP、Rust&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="exporter基础">Exporter基础&lt;/h3>
&lt;ul>
&lt;li>对于那些非用户可直接控制的应用代码来说 为其添加客户端库以进行直接测量很难实现
&lt;ul>
&lt;li>操作系统内核就是一个典型的示例 它显然不太可能易于实现添加自定义代码并通过HTTP协议输出Prometheus格式的指标&lt;/li>
&lt;li>但这一类程序一般都会通过某种接口输出其内在的指标 只不过这些指标可能有着特殊的格式 如: Linux内核的特有指标格式 或者SNMP指标格式等&lt;/li>
&lt;li>这些指标需要对它进行适当的解析和处理以转换为可用的目标格式 Exporter就是完成此类转换功能的应用程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Exporter独立运行于要获取其测量指标的应用程序之外 负责接收来自于Prometheus Server的指标获取请求 它通过目标应用程序(真正的目标)内置的指标接口获取指标数据 并将这些指标数据转换为可用的目标格式后响应给Prometheus
&lt;ul>
&lt;li>Exporter更像是&lt;strong>一对一&lt;/strong>的代理 它作为Prometheus Server的target存在 工作于应用程序的指标接口和Prometheus的文本指标格式之间转换数据格式&lt;/li>
&lt;li>Exporter不存储也不缓存任何数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="promql">PromQL&lt;/h2>
&lt;h3 id="promql简介">PromQL简介&lt;/h3>
&lt;ul>
&lt;li>Prometheus基于指标名称(metrics name)以及附属的标签集(labelset)唯一定义一条时间序列
&lt;ul>
&lt;li>指标名称代表着监控目标上某类可测量属性的基本特征标识&lt;/li>
&lt;li>标签则是这个基本特征上再次细分的多个可测量维度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于PromQL表达式 用户可以针对指定的特征及其细分维度进行过滤、聚合、统计等运算 从而产生期望的计算结果&lt;/li>
&lt;li>PromQL是Prometheus Server内置的数据查询语言
&lt;ul>
&lt;li>PromQL使用表达式(expression)来表达查询需求&lt;/li>
&lt;li>根据其使用的指标和标签 以及时间范围 表达式的查询请求可灵活覆盖在一个或多个时间序列的一定范围内的样本之上 甚至是只包含单个时间序列的单个样本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="prometheus时间序列">Prometheus时间序列&lt;/h4>
&lt;ul>
&lt;li>时间序列数据: 按照时间顺序 记录系统、设备状态变化的数据 每个数据称为一个&lt;strong>样本&lt;/strong>
&lt;ul>
&lt;li>数据采集以特定的时间周期进行 因而 随着时间流逝 将这些样本数据记录下来 将生成一个离散的样本数据序列&lt;/li>
&lt;li>该序列也称为向量(Vector) 而将多个序列放在同一个坐标系内(以时间为横轴 以序列为纵轴) 将形成一个由数据点组成的矩阵&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/prom-time-series.png"
width="2110"
height="864"
srcset="https://ilolicon.github.io/p/prometheus/icons/prom-time-series_hua6003164f96842ceb17eeedd47c3e51a_366084_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/prom-time-series_hua6003164f96842ceb17eeedd47c3e51a_366084_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="prom-time-series"
class="gallery-image"
data-flex-grow="244"
data-flex-basis="586px"
>&lt;/p>
&lt;h4 id="prometheus数据模型">Prometheus数据模型&lt;/h4>
&lt;ul>
&lt;li>Prometheus中 每个时间序列都由指标名称(Metric Name)和标签(Label)来唯一标识 格式为&lt;code>&amp;lt;metric name&amp;gt;{&amp;lt;label name&amp;gt;=&amp;lt;label value&amp;gt;, ...}&lt;/code>
&lt;ul>
&lt;li>指标名称: 通常用于描述系统上要测量的某个特征
&lt;ul>
&lt;li>如: &lt;code>http_requests_total&lt;/code>表示接收到的HTTP请求总数&lt;/li>
&lt;li>支持使用字母、数字、下划线和冒号 且必须能匹配RE2规范的正则表达式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>标签: 键值型数据 附加在指标名称之上 从而让指标能够支持多维度特征 可选
&lt;ul>
&lt;li>如: &lt;code>http_requests_total{method=&amp;quot;GET&amp;quot;}&lt;/code> 和 &lt;code>http_request_total{method=&amp;quot;POST&amp;quot;}&lt;/code>代表两个不同的时间序列&lt;/li>
&lt;li>标签名称可使用字母、数字和下划线 切必须能匹配RE2规范的正则表达式&lt;/li>
&lt;li>以 &lt;strong>_ _&lt;/strong> 为前缀的名称为Prometheus系统预留使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Metric Name的表示方式有两种
&lt;ul>
&lt;li>后一种通常用于Prometheus内部&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/prom-inner-metric.png"
width="1484"
height="556"
srcset="https://ilolicon.github.io/p/prometheus/icons/prom-inner-metric_hu840066708452de2ec0e5416445781111_138011_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/prom-inner-metric_hu840066708452de2ec0e5416445781111_138011_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="prom-inner-metric"
class="gallery-image"
data-flex-grow="266"
data-flex-basis="640px"
>&lt;/p>
&lt;h4 id="样本数据格式">样本数据格式&lt;/h4>
&lt;ul>
&lt;li>Prometheus的每个数据样本由两部分组成
&lt;ul>
&lt;li>float64格式的数据&lt;/li>
&lt;li>毫秒精度的时间戳&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/prom-data-format.png"
width="1914"
height="970"
srcset="https://ilolicon.github.io/p/prometheus/icons/prom-data-format_hudc8242f558e903a3081ccc24200335c3_872914_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/prom-data-format_hudc8242f558e903a3081ccc24200335c3_872914_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="prom-data-format"
class="gallery-image"
data-flex-grow="197"
data-flex-basis="473px"
>&lt;/p>
&lt;h4 id="指标名称及标签使用注意事项">指标名称及标签使用注意事项&lt;/h4>
&lt;ul>
&lt;li>指标名称和标签的特定组合代表着一个时间序列
&lt;ul>
&lt;li>指标名称相同 但标签不同的组合分别代表着不同的时间序列&lt;/li>
&lt;li>不同的指标名称自然更是标识不同的时间序列&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PromQL支持&lt;strong>基于定义的指标维度进行过滤和聚合&lt;/strong>
&lt;ul>
&lt;li>更改任何标签值 包括添加标签或删除标签 都会创建一个新的时间序列&lt;/li>
&lt;li>应该尽可能保持标签的稳定性 否则很可能创建新的时间序列 更甚者会生成一个动态的数据环境 并使得监控的数据源难以跟踪 从而导致建立在该指标之上的图形、告警记录规则变得无效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/mess-env.png"
width="1268"
height="644"
srcset="https://ilolicon.github.io/p/prometheus/icons/mess-env_hu6df8c11d87d1d316bc471f976612fc5c_332206_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/mess-env_hu6df8c11d87d1d316bc471f976612fc5c_332206_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="mess-env"
class="gallery-image"
data-flex-grow="196"
data-flex-basis="472px"
>&lt;/p>
&lt;h4 id="promql的数据类型">PromQL的数据类型&lt;/h4>
&lt;ul>
&lt;li>PromQL的表达式中支持4种数据类型
&lt;ul>
&lt;li>即时向量(Instant Vector): 特定或全部的时间序列集合上 具有相同时间戳的一组样本值 称为即时向量&lt;/li>
&lt;li>范围向量(Range Vector): 特定或全部的时间序列集合上 在指定的统一时间范围内的所有样本值&lt;/li>
&lt;li>标量(Scalar): 一个浮点型(float64)的数据值&lt;/li>
&lt;li>字符串(String): 支持使用单引号、双引号或反引号进行引用 但反引号中不会对转义字符串进行转义&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="时间序列选择器">时间序列选择器&lt;/h3>
&lt;h4 id="即时向量与范围向量">即时向量与范围向量&lt;/h4>
&lt;ul>
&lt;li>PromQL的查询操作需要针对有限个时间序列上的样本数据进行 挑选出目标时间序列是构建表达式最为关键的一步&lt;/li>
&lt;li>用户可以使用向量选择器表达式来挑选出给定指标名称下的所有时间序列或部分时间序列的即时(当前)样本值 或至过去某个时间范围内的样本值 前者称为即时向量选择器 后者称为范围向量选择器
&lt;ul>
&lt;li>即时向量选择器(Instant Vector Selectors): 返回0个、1个或多个时间序列上在给定时间戳(instant)上的各自的一个样本 该样本也可称为即时样本&lt;/li>
&lt;li>范围向量选择器(Range Vector Selectors): 返回0个、1个或多个时间序列上在给定时间范围内的各自的一组样本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/time-series-selectors.png"
width="1818"
height="762"
srcset="https://ilolicon.github.io/p/prometheus/icons/time-series-selectors_hu717012f3ef737e8e0f26deaff2858f5d_421468_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/time-series-selectors_hu717012f3ef737e8e0f26deaff2858f5d_421468_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="time-series-selectors"
class="gallery-image"
data-flex-grow="238"
data-flex-basis="572px"
>&lt;/p>
&lt;h4 id="向量表达式使用要点">向量表达式使用要点&lt;/h4>
&lt;ul>
&lt;li>表达式的返回值类型亦是即时向量、范围向量、标量或字符串4种数据类型其中之一 但是有些使用场景要求表达式返回值必须满足特定条件
&lt;ul>
&lt;li>需要将返回值绘制成图形时 仅支持即时向量类型的数据&lt;/li>
&lt;li>对于诸如&lt;code>rate&lt;/code>一类的速率函数来说 其要求使用的必须是范围向量型的数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>由于范围向量选择器返回的是范围向量型数据 它不能用于表达式浏览器中图形绘制功能 否则表达式浏览器会返回相应错误
&lt;ul>
&lt;li>事实上 范围向量几乎总是结合速率类的函数&lt;code>rate&lt;/code>一同使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="即时向量选择器">即时向量选择器&lt;/h4>
&lt;ul>
&lt;li>即时向量选择器由两部分组成
&lt;ul>
&lt;li>指标名称: 用于限定特定指标下的时间序列 即负责过滤指标 可选&lt;/li>
&lt;li>匹配器(Matcher): 或称为标签选择器 用于过滤时间序列上的标签 定义在{}中 可选&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>定义即时向量选择器时 以上两个部分应该至少给出一个 于是将存在下面三种组合
&lt;ul>
&lt;li>仅给定指标名称 或者标签名称上使用空值匹配器: 返回给定指标下的所有时间序列各自的即时样本
&lt;ul>
&lt;li>如: http_requests_total/http_requests_total{}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>仅给定匹配器: 返回所有符合给定匹配器的所有时间序列上的即时样本
&lt;ul>
&lt;li>注意: 这些时间序列可能有着不同的指标名称&lt;/li>
&lt;li>如: {job=~&amp;quot;.*&amp;quot;, method=&amp;ldquo;GET&amp;rdquo;}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>指标名称和匹配器的组合: 返回给定的指标下 且符合给定标签过滤器的所有时间序列上的即时样本
&lt;ul>
&lt;li>如: http_requests_total{methdo=&amp;ldquo;GET&amp;rdquo;}&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="匹配器matcher">匹配器(Matcher)&lt;/h4>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/prometheus/latest/querying/basics/#time-series-selectors" target="_blank" rel="noopener"
>time-series-selectors&lt;/a>&lt;/p>
&lt;ul>
&lt;li>匹配器用于定义标签过滤条件 目前支持4种匹配操作符
&lt;ul>
&lt;li>&lt;strong>=&lt;/strong>: Select labels that are exactly equal to the provided string.&lt;/li>
&lt;li>&lt;strong>!=&lt;/strong>: Select labels that are not equal to the provided string.&lt;/li>
&lt;li>&lt;strong>=~&lt;/strong>: Select labels that regex-match the provided string.&lt;/li>
&lt;li>&lt;strong>!~&lt;/strong>: Select labels that do not regex-match the provided string.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意事项
&lt;ul>
&lt;li>匹配到空标签值的匹配器时 所有未定义该标签的时间序列同样符合条件
&lt;ul>
&lt;li>如: &lt;code>http_requests_total{env=&amp;quot;&amp;quot;}&lt;/code>会匹配到&lt;code>http_requests_total{method=&amp;quot;GET&amp;quot;}&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>正则表达式将执行完全锚定机制 它需要匹配指定的标签的整个值&lt;/li>
&lt;li>向量选择器至少要包含一个指标名称 或者至少有一个不会匹配到空字符串的匹配器
&lt;ul>
&lt;li>如: &lt;code>{job=&amp;quot;&amp;quot;}&lt;/code> 为非法的选择器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用&lt;code>__name__&lt;/code>做为标签名称 还能够对指标名称进行过滤(联邦集群时常用到)
&lt;ul>
&lt;li>如: &lt;code>{__name__=~&amp;quot;http_requests_.*&amp;quot;}&lt;/code>能够匹配所有以&lt;code>http_requests_&lt;/code>为前缀的所有指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="范围向量选择器">范围向量选择器&lt;/h4>
&lt;ul>
&lt;li>同即时向量选择器的唯一不同之处在于 范围向量选择器需要在表达式后紧跟一个方括号[]来表达需在时间序列上返回的样本所处的时间范围
&lt;ul>
&lt;li>时间范围: 以当前的时间为基准的时间点 只想过去一个特定的时间长度&lt;/li>
&lt;li>如: [5m] 指过去5分钟之内&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>时间格式: 一个整数后紧跟一个时间单位(Time Durations)
&lt;ul>
&lt;li>可用单位: ms(毫秒)/s(秒)/m(分钟)/h(小时)/d(天)/w(周)/y(年)&lt;/li>
&lt;li>必须使用整数时间 且能够将多个不同级别的单位进行组合 以时间单位由大到小排序
&lt;ul>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 1h30m&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> &lt;del>1.5h&lt;/del>&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 5h&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 10s&lt;/li>
&lt;li>&lt;input checked="" disabled="" type="checkbox"> 2d&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>需要注意的是 范围向量选择器返回的是一定时间范围内的数据样本 虽然不同时间序列的数据抓取时间点相同 但它们的时间戳并不会严格对齐
&lt;ul>
&lt;li>多个Target上的数据抓取需要分散在抓取时间点前后一定的时间范围内 以均衡Prometheus Server的负载&lt;/li>
&lt;li>因而 Prometheus在趋势上准确 但并非绝对精准&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="偏移量修改器">偏移量修改器&lt;/h4>
&lt;ul>
&lt;li>默认情况下 即时向量选择器和范围向量选择器都以当前时间为基准时间点 而偏移量修改器能够修改该基准&lt;/li>
&lt;li>偏移量修改器的使用方法是紧跟在选择器表达式之后使用&lt;strong>offset&lt;/strong>关键字指定
&lt;ul>
&lt;li>&lt;code>http_requests_total offset 5m&lt;/code> 表示获取以http_requests_total为指标名称的所有时间序列在过去5分钟时的&lt;strong>即时样本&lt;/strong>&lt;/li>
&lt;li>&lt;code>http_requests_total[5m] offset 1d&lt;/code> 表示获取距此刻1天时间之前的5分钟之内的所有样本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/offset-modifier.png"
width="1540"
height="498"
srcset="https://ilolicon.github.io/p/prometheus/icons/offset-modifier_hu2c70e9b3dc79cbee7c5ee4837d32be98_120975_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/offset-modifier_hu2c70e9b3dc79cbee7c5ee4837d32be98_120975_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="offset-modifier"
class="gallery-image"
data-flex-grow="309"
data-flex-basis="742px"
>&lt;/p>
&lt;h3 id="promql指标类型">PromQL指标类型&lt;/h3>
&lt;ul>
&lt;li>PromQL主要有四个指标类型 它们主要由Prometheus的客户端库使用
&lt;ul>
&lt;li>Counter: 计数器 单调递增 除非重置(如: 服务器或进程重启)&lt;/li>
&lt;li>Gauge: 仪表盘 可增可减的数据&lt;/li>
&lt;li>Histogram: 直方图 将时间单位内的数据划分成不同的时间段 并各自评估其样本个数及样本值之和 因而可计算出分位数
&lt;ul>
&lt;li>可用于分析因异常值而引起的平均值过大的问题&lt;/li>
&lt;li>分位数计算要使用专用的histogram_quantile函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Summary: 类似直方图 但客户端会直接计算并上报分位数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Prometheus Server并不使用类型信息 而是将所有数据展平为时间序列&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/prom-metrics-types.png"
width="1844"
height="584"
srcset="https://ilolicon.github.io/p/prometheus/icons/prom-metrics-types_hu4e289c9fabc9f33a07d2178a7b4daa4f_306160_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/prom-metrics-types_hu4e289c9fabc9f33a07d2178a7b4daa4f_306160_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="prom-metrics-type"
class="gallery-image"
data-flex-grow="315"
data-flex-basis="757px"
>&lt;/p>
&lt;h4 id="counter和gauge">Counter和Gauge&lt;/h4>
&lt;ul>
&lt;li>通常 Counter的总数并没有直接作用 而使需要借助于rate、topk、increase和irate等函数来生成样本数据的变化状况(增长率)
&lt;ul>
&lt;li>&lt;code>rate(hrrp_requests_total[2h])&lt;/code> 获取2小时内 该指标下各时间序列上的http总请求数的增长速率&lt;/li>
&lt;li>&lt;code>topk(3, http_requests_total)&lt;/code> 获取该指标下http请求总数排名前3的时间序列&lt;/li>
&lt;li>&lt;code>irate(http_request_total[2h])&lt;/code> 高灵敏度函数 用于计算指标的瞬时速率
&lt;ul>
&lt;li>基于样本范围内的最后两个样本进行计算 相较于rate函数来说 irate更适合用于短期时间范围内的变化速率分析&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Gauge用于存储其值可增可减的指标样本数据 常用于进行求和、取平均值、最小值、最大值等聚合计算 也会经常结合PromQL的predict_linear和delta函数使用
&lt;ul>
&lt;li>&lt;code>predict_linear(v range-vector, t, scaler)&lt;/code>函数可以预测时间序列v在t秒后的值 它通过线性回归的方式来预测样本数据的Gauge变化趋势&lt;/li>
&lt;li>&lt;code>delta(v range-vector)&lt;/code>函数计算范围向量中每个时间序列元素的第一个值与最后一个值之差 从而展示不同时间点上的样本值差值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="histogram">Histogram&lt;/h4>
&lt;ul>
&lt;li>Histogram是一种对数据分布情况的图形展示 由一系列高度不等的长条图(bar)或线段表示 用于&lt;strong>展示耽搁测度的值的分布&lt;/strong>
&lt;ul>
&lt;li>它一般用横轴表示某个指标维度的数据取值的分布状况 用纵轴表示样本统计的频率和频数 从而能够以二维图的形式展现数值的分布状况&lt;/li>
&lt;li>为了构建Histogram 首先需要将值的范围进行分段 即将所有值的整个可用范围分成一系列连续、相邻(相邻出可以是等同值)但不重叠的间隔 而后统计每个间隔中有多少值&lt;/li>
&lt;li>从统计学的角度看 分位数不能被聚合 也不能进行算数运算&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/histogram.png"
width="1304"
height="762"
srcset="https://ilolicon.github.io/p/prometheus/icons/histogram_hud8d1c004fe6913a2d3de4debecd7e325_391582_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/histogram_hud8d1c004fe6913a2d3de4debecd7e325_391582_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="histogram"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="410px"
>&lt;/p>
&lt;ul>
&lt;li>对于Prometheus来说 Histogram会在一段时间范围内对数据进行采样(通常是请求持续时长或响应大小等) 并将其计入可配置的bucket(存储桶)中
&lt;ul>
&lt;li>Histogram事先将特定测度可能的取值范围分割为多个样本空间 并通过对落入bucket内的观测值进行计算以及求和操作&lt;/li>
&lt;li>与常规的方式略有不同的是 Prometheus取值间隔的划分采用的是累积(Cumulative)区间间隔机制 及每个bucket中的样本均包含了其前面所有bucket中的样本 因而也称为累积直方图
&lt;ul>
&lt;li>可降低Histogram的维护成本&lt;/li>
&lt;li>支持粗略计算样本值的分位数&lt;/li>
&lt;li>单独提供了_sum和_count指标 从而支持计算平均值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/histogram-cumulative.png"
width="942"
height="806"
srcset="https://ilolicon.github.io/p/prometheus/icons/histogram-cumulative_hu1ffa6f457cffa2ba9ad41bc62ede6d6c_170960_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/histogram-cumulative_hu1ffa6f457cffa2ba9ad41bc62ede6d6c_170960_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="histogram-cumulative"
class="gallery-image"
data-flex-grow="116"
data-flex-basis="280px"
>&lt;/p>
&lt;ul>
&lt;li>Histogram类型的每个指标有一个基础指标名称&lt;code>&amp;lt;basename&amp;gt;&lt;/code> 它会提供多个时间序列
&lt;ul>
&lt;li>&lt;code>&amp;lt;basename&amp;gt;_bucket{le=&amp;quot;&amp;lt;upper inclusive bound&amp;gt;&amp;quot;}&lt;/code>: 观测桶的上边界 及样本统计区间；最大区间(包含所有样本)的名称为&lt;code>&amp;lt;basename&amp;gt;_bucket{le=&amp;quot;+Inf&amp;quot;}&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;basename&amp;gt;_sum&lt;/code>: 所有样本观测值的总和&lt;/li>
&lt;li>&lt;code>&amp;lt;basename&amp;gt;_count&lt;/code>: 总的观测次数 它自身本质上是一个Counter类型的指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>累积间隔机制生成的样本数据需要额外使用内置的histogram_quantile()函数 即可根据Histogram指标来计算相应的分位数(quantile) 及某个bucket的样本数在所有样本数中所占的比例
&lt;ul>
&lt;li>&lt;code>histogram_quantile()&lt;/code>函数在计算分位数时会假定每个区间内的样本满足线性分布状态 因为它的结果是一个预估值 并不完全准确&lt;/li>
&lt;li>预估的准确度取决于bucket区间划分的粒度 粒度越大 准确度越低&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="summary">Summary&lt;/h4>
&lt;ul>
&lt;li>指标类型是客户端库的特性 而Histogram在客户端仅是简单的桶划分和分桶计数 分位数的计算由Prometheus Server基于样本数据进行估算 因而其结果未必准确 甚至不合理的bucket划分会导致较大的误差&lt;/li>
&lt;li>Summary是一种类似于Histogram的指标类型 但它在客户端于一段时间内默认10分钟)的每个采样点进行统计 计算并存储了分位数数值 Server端直接抓取相应值即可&lt;/li>
&lt;li>但是 Summary不支持sum和avg一类的集合运算 而且其分位数由客户端计算并生成 Server端无法获取客户端未定义的分位数 而Histogram可通过PromQL任意定义 有着较好的灵活性&lt;/li>
&lt;li>对于每个指标 Summary以指标名称&lt;code>&amp;lt;basename&amp;gt;&lt;/code>为前缀 生成如下几个时间序列
&lt;ul>
&lt;li>&lt;code>&amp;lt;basename&amp;gt;{quantile=&amp;quot;&amp;lt;φ&amp;gt;&amp;quot;}&lt;/code> 其中φ是分位点 其取值范围是(0&amp;lt;=φ&amp;lt;=1) 计数器类型指标 如下是几种典型的分位点
&lt;ul>
&lt;li>0、0.25、0.5、0.75和1几个分位点&lt;/li>
&lt;li>0.5、0.9和0.99几个分位点&lt;/li>
&lt;li>0.01、0.05、0.5、0.9和0.99几个分位点&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>&amp;lt;basename&amp;gt;_sum&lt;/code> 抓取到的所有样本值之和&lt;/li>
&lt;li>&lt;code>&amp;lt;basename&amp;gt;_count&lt;/code> 抓取到的所有样本总数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="promql运算">PromQL运算&lt;/h3>
&lt;h4 id="prometheus的聚合函数">Prometheus的聚合函数&lt;/h4>
&lt;ul>
&lt;li>一般来说 单个指标的价值不大 监控场景中往往需要联合并可视化一组指标 这种联合机制即时指&lt;strong>聚合&lt;/strong>操作 如: 将计数、求和、平均值、分位数、标准差及方差等统计函数应用于时间序列的样本之上生成具有统计学意义的结果等&lt;/li>
&lt;li>对查询结果事先按照某种分类机制进行分组(groupby) 并将查询结果按组进行聚合计算也是较为常见的需求 如: 分组统计、分组求平均值、分组求和等&lt;/li>
&lt;li>聚合操作由&lt;strong>聚合函数&lt;/strong>针对一组值进行计算并返回单个值或少量几个值作为记过
&lt;ul>
&lt;li>Prometheus内置提供的11个聚合函数也称为聚合运算符&lt;/li>
&lt;li>这些运算符&lt;strong>仅支持&lt;/strong>应用于&lt;strong>单个即时向量&lt;/strong>的元素 器返回值也是具有少量元素的新向量或标量&lt;/li>
&lt;li>这些聚合运算符既可以基于向量表达式返回结果中的时间序列的所有标签维度进行分组聚合 也可以仅基于指定的标签维度分组后再进行分组聚合&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="聚合表达式">聚合表达式&lt;/h4>
&lt;ul>
&lt;li>PromQL中的聚合操作语法格式可采用如下两种格式之一
&lt;ul>
&lt;li>&lt;code>&amp;lt;aggr-op&amp;gt;([parameter,]&amp;lt;vector expression&amp;gt;)[without|by(&amp;lt;label list&amp;gt;)]&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;aggr-op&amp;gt;[without|by(label list)]([parameter,]&amp;lt;vector expression&amp;gt;)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>分组聚合: 先分组、在聚合
&lt;ul>
&lt;li>without: 从结果向量中删除由without指定的标签 未指定的那部分标签则用作分组标准&lt;/li>
&lt;li>by: 功能和without相反 它仅使用by子句中指定的标签进行聚合 结果向量中出现但未被by子句执行的标签则会被忽略
&lt;ul>
&lt;li>为了保留上下文信息 使用by子句时需要显式指定其结果中原本出现的job、instance等一类的标签&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>事实上 各函数工作机制的不同之处也仅在于计算操作本身 PromQL对它们的执行逻辑相似&lt;/li>
&lt;/ul>
&lt;h4 id="11个聚合函数">11个聚合函数&lt;/h4>
&lt;ul>
&lt;li>sum(): 对样本值求和&lt;/li>
&lt;li>avg(): 对样本值求平均值 这是进行指标数据分析的标准方法&lt;/li>
&lt;li>count(): 对分组内的时间序列进行数量统计&lt;/li>
&lt;li>stddev(): 对样本值求标准差 以帮组用户了解数据的波动大小(或称之为波动程度)&lt;/li>
&lt;li>stdvar(): 对样本值求方差 它是求取标准差过程中的中间状态&lt;/li>
&lt;li>min(): 求取样本值中的最小者&lt;/li>
&lt;li>max(): 求取样本值中的最大者&lt;/li>
&lt;li>topk(): 逆序返回分组内的样本值最大的前k个时间序列及其值&lt;/li>
&lt;li>bottomk(): 顺序返回分组内样本值最小的前k个时间序列及其值&lt;/li>
&lt;li>quanlite(): 分位数用于评估数据的分布状态 该函数会返回分组内指定的分位数的值 即数值落在小于等于执行的分位区间的比例&lt;/li>
&lt;li>count_values(): 对分组内的时间序列的样本值进行数量统计&lt;/li>
&lt;/ul>
&lt;h4 id="二元运算符">二元运算符&lt;/h4>
&lt;ul>
&lt;li>PromQL支持基本的算数运算和逻辑运算 这类运算支持使用操作符连接两个操作数 因而也称为二元运算符或二元操作符
&lt;ul>
&lt;li>支持的运算
&lt;ul>
&lt;li>两个标量间运算&lt;/li>
&lt;li>即时向量和标量间的运算: 将运算符应用于向量上的每个样本&lt;/li>
&lt;li>两个即时向量间的运算: 遵循向量匹配机制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将运算符用于两个即时向量间的运算时 可基于&lt;strong>向量匹配&lt;/strong>模式定义器运算机制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>算数运算
&lt;ul>
&lt;li>支持运算符: +、-、*、/、%(取模)、^(幂运算)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>比较运算
&lt;ul>
&lt;li>支持运算符: ==、!=、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>逻辑/集合运算
&lt;ul>
&lt;li>支持的运算符: and、or、unless(除了)&lt;/li>
&lt;li>目前 该运算仅允许在两个即时向量间进行 尚不支持标量参与运算&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="向量匹配">向量匹配&lt;/h4>
&lt;ul>
&lt;li>即时向量间的运算时PromQL的特色之一 运算时 PromQL会为左侧向量中的那个元素找到匹配的元素 其匹配行为有两种基本类型
&lt;ul>
&lt;li>一对一(One-to-One)&lt;/li>
&lt;li>一对多或多对一(Many-to-One One-to-Many)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="向量一对一匹配">向量一对一匹配&lt;/h5>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/prometheus/latest/querying/operators/#one-to-one-vector-matches" target="_blank" rel="noopener"
>one-to-one-vector-matches&lt;/a>&lt;/p>
&lt;ul>
&lt;li>即时向量的一对一匹配
&lt;ul>
&lt;li>从运算符的两边表达式所获取的即时向量间一次比较 并找到唯一匹配(标签完全一致)的样本值&lt;/li>
&lt;li>找不到匹配项的值则不会出现在结果中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匹配表达式语法
&lt;ul>
&lt;li>&lt;code>&amp;lt;vector expr&amp;gt; &amp;lt;bin-op&amp;gt; ignoring(&amp;lt;label list&amp;gt;) &amp;lt;vector expr&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;vector expr&amp;gt; &amp;lt;bin-op&amp;gt; on(&amp;lt;label list&amp;gt;) &amp;lt;vector expr&amp;gt;&lt;/code>
&lt;ul>
&lt;li>ignore: 定义匹配检测时要忽略的标签&lt;/li>
&lt;li>on: 定义匹配检测时只使用的标签&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如: &lt;code>rate(http_requests_total{status_code=~&amp;quot;5.*&amp;quot;}[5m]) &amp;gt; .1*rate(http_requests_total[5m])&lt;/code>
&lt;ul>
&lt;li>左侧会生成一个即时向量 它计算出5xx响应码的各类请求的增长速率
&lt;ul>
&lt;li>除了status_code标签外 该指标通常还有其他标签 于是 status_code的值为500的标签同其他标签的每个组合代表一个时间序列 其相应的即时样本即为结果向量的一个元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>右侧会生成一个即时向量 它计算出所有标签组合所代表的各类请求的增长速率&lt;/li>
&lt;li>计算时 PromQL会在操作符左右两侧的结果元素中找到标签完全一致的元素进行比较&lt;/li>
&lt;li>其意义为: 计算出每类请求中的5xx响应码在该类请求中所占的比例&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="一对多多对一匹配">一对多/多对一匹配&lt;/h5>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/prometheus/latest/querying/operators/#many-to-one-and-one-to-many-vector-matches" target="_blank" rel="noopener"
>many-to-one-and-one-to-many-vector-matches&lt;/a>&lt;/p>
&lt;ul>
&lt;li>一对多/多对一匹配
&lt;ul>
&lt;li>&lt;strong>一&lt;/strong>侧的每个元素 可与&lt;strong>多&lt;/strong>侧的多个元素进行匹配&lt;/li>
&lt;li>必须使用group_left或group_right明确指定哪侧为&lt;strong>多&lt;/strong>侧&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匹配表达式语法
&lt;ul>
&lt;li>&lt;code>&amp;lt;vector expr&amp;gt; &amp;lt;bin-op&amp;gt; ignoring(&amp;lt;label list&amp;gt;) group_left(&amp;lt;label list&amp;gt;) &amp;lt;vector expr&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;vector expr&amp;gt; &amp;lt;bin-op&amp;gt; ignoring(&amp;lt;label list&amp;gt;) group_right(&amp;lt;label list&amp;gt;) &amp;lt;vector expr&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;vector expr&amp;gt; &amp;lt;bin-op&amp;gt; on(&amp;lt;label list&amp;gt;) group_left(&amp;lt;label list&amp;gt;) &amp;lt;vector expr&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;lt;vector expr&amp;gt; &amp;lt;bin-op&amp;gt; on(&amp;lt;label list&amp;gt;) group_left(&amp;lt;label list&amp;gt;) &amp;lt;vector expr&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="服务发现">服务发现&lt;/h2>
&lt;ul>
&lt;li>Prometheus指标抓取的生命周期
&lt;ul>
&lt;li>发现 -&amp;gt; 配置 -&amp;gt; relabel -&amp;gt; 指标数据抓取 -&amp;gt; metrics relabel&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Prometheus Server监控Target
&lt;ul>
&lt;li>静态配置(static configs)&lt;/li>
&lt;li>动态发现/Prometheus的服务发现(监控环境变化频繁/动态环境)
&lt;ul>
&lt;li>基于文件的服务发现
&lt;ul>
&lt;li>略优于静态配置 不依赖于任何第三方服务或平台 因而也是最简单和通用的实现方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于DNS的服务发现&lt;/li>
&lt;li>基于API的服务发现: Kubernetes、Consul、Azure、&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重新标记
&lt;ul>
&lt;li>target重新打标&lt;/li>
&lt;li>mertric重新打标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="为何要进行服务发现">为何要进行服务发现&lt;/h3>
&lt;ul>
&lt;li>Prometheus Server的数据抓取工作于Pull模型 因而 它必须事先知道各Target的位置 然后才能从相应的Exporter或Instrumentation中抓取数据
&lt;ul>
&lt;li>对于小型的系统环境来说 通过static_configs指定各Target便能解决问题 这也是最简单的配置方法
&lt;ul>
&lt;li>每个Targets用一个网络端点(ip:port)标识&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于中大型的系统环境或具有较强动态性的云计算环境来说 静态配置显然难以适用&lt;/li>
&lt;li>Prometheus为此专门设计了一组服务发现机制 以便于能够基于服务注册中心(服务总线)自动发现、检测、分类可被监控的各Target 以及更新发生了变动的Target&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="指标抓取的生命周期">指标抓取的生命周期&lt;/h3>
&lt;ul>
&lt;li>下图展示了Prometheus上进行指标抓取的简单生命周期
&lt;ul>
&lt;li>在每个scrape_interval期间 Prometheus都会检查执行的作业(Job)&lt;/li>
&lt;li>这些作业首先会根据Job上指定的发现配置生成target列表 此即服务发现的过程
&lt;ul>
&lt;li>服务发现会返回一个Target列表 其中包含一组称为元数据的标签 这些标签都以&lt;code>__meta__&lt;/code>为前缀&lt;/li>
&lt;li>服务发现还会根据目标配置来设置其他标签 这些标签带有&lt;code>__&lt;/code>前缀和后缀 包括&lt;code>__scheme__&lt;/code> &lt;code>__address__&lt;/code> &lt;code>__metrics_path__&lt;/code> 分别保存target支持使用的协议(http/https 默认http) target的地址以及指标的URI路径(默认为/metrics)&lt;/li>
&lt;li>若URI路径中存在任何参数 则它们的前缀会设置为&lt;code>__param__&lt;/code>&lt;/li>
&lt;li>这些目标列表金和标签会返回给Prometheus 其中的一些标签也可以配置中被覆盖&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>配置标签会在抓取的生命周期中被重复利用以生成其他标签 如: 指标上的instance标签的默认值就来自于__address__标签的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/metrics-pull-life-cycle.png"
width="2182"
height="368"
srcset="https://ilolicon.github.io/p/prometheus/icons/metrics-pull-life-cycle_hu0d291904c7f3b43eb1ba8effac244ec1_268497_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/metrics-pull-life-cycle_hu0d291904c7f3b43eb1ba8effac244ec1_268497_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="metrics-pull-life-cycle"
class="gallery-image"
data-flex-grow="592"
data-flex-basis="1423px"
>&lt;/p>
&lt;ul>
&lt;li>对于发现的各目标 Prometheus提供了可以重新标记(relabel)目标的机会
&lt;ul>
&lt;li>它定义在job配置段的relabel_config配置中 常用于实现如下功能
&lt;ul>
&lt;li>将来自服务发现的元数据标签中的信息附加到指标的标签上&lt;/li>
&lt;li>过滤目标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在这之后 便是数据抓取、以及指标返回的过程&lt;/li>
&lt;li>抓取而来的指标在保存之前 还允许用户对指标重新打标并过滤
&lt;ul>
&lt;li>它定义在job配置段的metric_relabel_configs配置中 常用语实现如下功能
&lt;ul>
&lt;li>删除不必要的指标&lt;/li>
&lt;li>从指标中删除敏感或不需要的标签&lt;/li>
&lt;li>添加、编辑或修改指标的标签值或标签格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="可集成的服务发现机制">可集成的服务发现机制&lt;/h3>
&lt;ul>
&lt;li>不同场景中 服务注册中心的指代也有所不同
&lt;ul>
&lt;li>共有云或私有IaaS云 自身保存有平台上的所有资源信息 其API Server便可以作为Prometheus的服务发现媒介
&lt;ul>
&lt;li>azure、ec2、digitalocean、gce、tencent cloud、alibaba cloud&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Prometheus也可以集成到多种不同的开源服务发现工具上 以动态发现需要监控的目标
&lt;ul>
&lt;li>Consul、Eureka Zookeeper Serverset或Airbnb Nerve等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Prometheus也可以很好的集成到Kubernetes平台上 通过其API Server动态发现各类被监控的Pod、Service、End point、Ingress和Node对象
&lt;ul>
&lt;li>它也支持基于dockerswarm和marathon两款编排工具进行服务发现机制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Prometheus还支持基于基于DNS、文件或HTTP的动态发现机制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="对target重新打标">对Target重新打标&lt;/h3>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config" target="_blank" rel="noopener"
>relabel-config&lt;/a>&lt;/p>
&lt;ul>
&lt;li>对target重新达标是在&lt;strong>数据抓取之前&lt;/strong>动态重写target标签的强大工具 在每个数据抓取配置中 可以定义多个relabel步骤 他们将按照定义的顺序依次执行&lt;/li>
&lt;li>对于发现的每个target Prometheus默认会执行如下操作
&lt;ul>
&lt;li>job的标签设定为其所属的job_name的值&lt;/li>
&lt;li>&lt;code>__address__&lt;/code>标签的值为该target的套接字地址&lt;code>&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>instance&lt;/code>标签的值为&lt;code>__address__&lt;/code>的值&lt;/li>
&lt;li>&lt;code>__scheme__&lt;/code>标签的值为抓取该target上指标时使用的协议(http或https)&lt;/li>
&lt;li>&lt;code>__metrics_path__&lt;/code>标签的值为抓取该target上的指标时使用的URI路径 默认为/metrics&lt;/li>
&lt;li>&lt;code>__param_&amp;lt;name&amp;gt;&lt;/code>标签的值为传递的URI参数中第一个名称为&lt;code>&amp;lt;name&amp;gt;&lt;/code>的参数的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重新打标记期间 还可以使用该target上以&lt;code>__meta__&lt;/code>开头的元标签
&lt;ul>
&lt;li>各服务发现机制为其target添加的元标签会有所不同&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重新标记完成后 该target上以&lt;code>__&lt;/code>开头的所有标签都会被移除
&lt;ul>
&lt;li>若在relabel过程中需要临时存储标签值 则需要使用__tmp标签名称为前缀进行保存 依避免同Prometheus的内建标签冲突&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="relabel_config">relabel_config&lt;/h4>
&lt;p>&lt;a class="link" href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config" target="_blank" rel="noopener"
>relabel_config&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># The source labels select values from existing labels. Their content is concatenated&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># using the configured separator and matched against the configured regular expression&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># for the replace, keep, and drop actions.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> source_labels: &lt;span class="s1">&amp;#39;[&amp;#39;&lt;/span> &amp;lt;labelname&amp;gt; &lt;span class="o">[&lt;/span>, ...&lt;span class="o">]&lt;/span> &lt;span class="s1">&amp;#39;]&amp;#39;&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Separator placed between concatenated source label values.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> separator: &amp;lt;string&amp;gt; &lt;span class="p">|&lt;/span> &lt;span class="nv">default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Label to which the resulting value is written in a replace action.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># It is mandatory for replace actions. Regex capture groups are available.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> target_label: &amp;lt;labelname&amp;gt; &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Regular expression against which the extracted value is matched.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> regex: &amp;lt;regex&amp;gt; &lt;span class="p">|&lt;/span> &lt;span class="nv">default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>.*&lt;span class="o">)&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Modulus to take of the hash of the source label values.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> modulus: &amp;lt;int&amp;gt; &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Replacement value against which a regex replace is performed if the&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># regular expression matches. Regex capture groups are available.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> replacement: &amp;lt;string&amp;gt; &lt;span class="p">|&lt;/span> &lt;span class="nv">default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nv">$1&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Action to perform based on regex matching.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> action: &amp;lt;relabel_action&amp;gt; &lt;span class="p">|&lt;/span> &lt;span class="nv">default&lt;/span> &lt;span class="o">=&lt;/span> replace &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="relabel_configs">relabel_configs&lt;/h4>
&lt;ul>
&lt;li>&lt;code>&amp;lt;relabal_action&amp;gt;&lt;/code>字段用于定义重新标记的行为 其可用取值如下
&lt;ul>
&lt;li>替换标签值
&lt;ul>
&lt;li>replace: 首先将source_labels中指定的各标签值进行串连 而后将regex字段中的正则表达式对源标签值进行匹配判定 若匹配 则将target_label字段中指定的标签值替换为replacement字段中保存的值
&lt;ul>
&lt;li>replacement可按需引用保存regex中的某个&lt;strong>分组模式&lt;/strong>匹配到的值 默认保存整个regex匹配到的内容&lt;/li>
&lt;li>进行值替换时 replacement字段中指定标签的值也支持以分组格式进行引用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>hashmod: 将target_label的值设置为一个hash值 该hash则由models字段指定的hash模块对source_labels上各标签的串连值进行hash计算生成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除指标: 该处的每个指标名称对应一个target
&lt;ul>
&lt;li>keep: regex&lt;strong>不能&lt;/strong>匹配到target上的source_labels上的&lt;strong>各标签的串连值&lt;/strong>时 则删除该target&lt;/li>
&lt;li>drop: regex&lt;strong>能&lt;/strong>匹配到target上的source_labels上的&lt;strong>各标签的串连值&lt;/strong>时 则删除该target&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建或删除标签
&lt;ul>
&lt;li>labelmap: 将regex对所有的&lt;strong>标签名&lt;/strong>进行匹配判定 而后将匹配到的标签的值赋给replacement字段指定的标签名之上 通常用于取出匹配的标签名的一部分生成新标签&lt;/li>
&lt;li>labeldrop: 将regex对所有的标签名进行匹配判定 能够匹配到的标签将从该target的标签集中删除&lt;/li>
&lt;li>labelkeep: 将regex对所有的标签名进行匹配判定 不能够匹配到的标签将从该target的标签集中删除&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意: 要确保在labeldrop或labelkeep操作后 余下的标签集依然能够唯一标识该指标&lt;/li>
&lt;/ul>
&lt;h5 id="replace示例">replace示例&lt;/h5>
&lt;ul>
&lt;li>下面示例将三个源标签的值按顺序串连后 由指定的正则表达式进行模式匹配 然后由replacement引用模式匹配的结果并加以改造 将其赋值给endpoint标签&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;nodes&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">file_sd_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">files&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">targets/prometheus/node*.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">relabel_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">source_labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">__scheme__&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">__address__&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">__metrics_path__&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">regex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;(http|https)(.*)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">separator&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">target_label&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;endpoint&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replacement&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;${1}://${2}&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">action&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">replace&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="labelmap示例">labelmap示例&lt;/h5>
&lt;ul>
&lt;li>下面的示例 将regex指定的模式对target上所有的标签进行匹配判定 对于匹配到的标签名 它将以该标签名中匹配的部分为前缀 指定的&lt;code>_name&lt;/code>为后缀生成新的标签名 而新标签的值则与其原标签的值相同&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">- &lt;span class="nt">job&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;nodes&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">file_sd_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">fles&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">targets/prometheus/node*.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">relabel_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">regex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;(job|app)&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">replacement&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;${1}_name&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">action&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">labelmap&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="对抓取到的metric重新打标">对抓取到的metric重新打标&lt;/h3>
&lt;ul>
&lt;li>对metric重新打标时在&lt;strong>数据抓取之后&lt;/strong>动态重写metric标签的工具 在每个数据抓取配置中 可以定义多个metric relabel步骤 它们按照定义的顺序依次执行
&lt;ul>
&lt;li>删除不必要的指标&lt;/li>
&lt;li>从指标中删除敏感或不需要的标签&lt;/li>
&lt;li>添加、编辑或修改指标的标签值或标签格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对metric重新打标的配置格式与target重新打标的格式相同 但前者要定义在专用的metric_relabel_configs字段中&lt;/li>
&lt;li>要注意的是 更改或添加标签会创建新的时间序列
&lt;ul>
&lt;li>应该明确地使用各个标签 并尽可能保持不变 以避免创建出一个动态的数据环境&lt;/li>
&lt;li>标签是时间序列的唯一约束 删除标签并导致时间序列重复时 可能会导致系统出现问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="metric-relabel删除示例">metric relabel删除示例&lt;/h4>
&lt;ul>
&lt;li>在source_label字段上 通过指标上的元标签&lt;code>__name__&lt;/code>引用指标名称 而后由regex进行匹配判断 可使用drop action删除匹配的指标 或使用keep action仅保留匹配的指标&lt;/li>
&lt;li>下面的示例 用于在相应的job上 在发现的各target上 删除以 go_info 为前缀的指标&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">- &lt;span class="nt">job_name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;nodes&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">file_sd_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">files&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">targets/prometheus/node*.yaml&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">metric_relabel_configs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="nt">source_labels&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>- &lt;span class="l">__name__&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">regex&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;go_info.*&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">action&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">drop&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="查询持久化可视化">查询持久化/可视化&lt;/h2>
&lt;p>&lt;a class="link" href="https://grafana.com/" target="_blank" rel="noopener"
>grafana&lt;/a>&lt;/p>
&lt;ul>
&lt;li>记录规则(recording rule)&lt;/li>
&lt;li>告警规则(alert rule)&lt;/li>
&lt;/ul>
&lt;h2 id="alertmanager">Alertmanager&lt;/h2>
&lt;h3 id="告警功能概述">告警功能概述&lt;/h3>
&lt;ul>
&lt;li>Prometheus对指标的收集、存储同告警能力分数于Prometheus Server和Alertmanager两个独立的组件 前者仅负责基于&lt;strong>告警规则&lt;/strong>生成告警通知 具体的告警操作由后者完成&lt;/li>
&lt;li>alertmanager负责处理由客户端发来的告警通知
&lt;ul>
&lt;li>客户端通常是Prometheus Server 但它也支持接收来自其它工具的告警&lt;/li>
&lt;li>alertmanager对告警通知进行分组、去重后 根据路由规则将其路由到不同的receiver 如: Email、钉钉、企业微信等&lt;img src="https://ilolicon.github.io/p/prometheus/icons/alert-function.png"
width="1394"
height="838"
srcset="https://ilolicon.github.io/p/prometheus/icons/alert-function_hu2acb61bb20289256c0c05d7b41a0061a_365148_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/alert-function_hu2acb61bb20289256c0c05d7b41a0061a_365148_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="alert-function"
class="gallery-image"
data-flex-grow="166"
data-flex-basis="399px"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="告警逻辑">告警逻辑&lt;/h3>
&lt;ul>
&lt;li>首先要配置Prometheus成为Alertmanager的告警客户端
&lt;ul>
&lt;li>反过来 Alertmanager也是应用程序 它自身同样应该纳入Prometheus的监控目标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>配置逻辑
&lt;ul>
&lt;li>在Alertmanager上定义receiver 他们通常是能够基于某个媒介接收告警信息的特定用户
&lt;ul>
&lt;li>Email、WeChat、Pagerduty和Webhook等是最为常见的发送告警信息的媒介&lt;/li>
&lt;li>在不同的媒介上 代表告警信息接收人的地址表示方式也会有所不同&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在Alertmanager上定义路由规则(route) 以便将收到的告警通知按需分别进行处理
&lt;ul>
&lt;li>alertmanager的route配置段支持定义&lt;strong>树&lt;/strong>状路由表 入口位置成为根节点 每个字节点可以基于匹配条件定义出一个独立的路由分支&lt;/li>
&lt;li>所有告警都将进入路由根节点 而后进行子节点遍历&lt;/li>
&lt;li>若路由上的continue字段的值为false 则遇到第一个匹配的路由分支后即终止 否则将继续匹配后续的字节点&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在Prometheus上定义&lt;strong>告警规则&lt;/strong>生成告警通知 发送给Alertmanager&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/prometheus/icons/alert-logic.png"
width="2210"
height="726"
srcset="https://ilolicon.github.io/p/prometheus/icons/alert-logic_hu667e046a03ead91bda2d4475a1396f58_461782_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/prometheus/icons/alert-logic_hu667e046a03ead91bda2d4475a1396f58_461782_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="alert-logic"
class="gallery-image"
data-flex-grow="304"
data-flex-basis="730px"
>&lt;/p>
&lt;h3 id="alertmanager特性">Alertmanager特性&lt;/h3>
&lt;ul>
&lt;li>除了基本的告警通知能力外 Alertmanager还支持对告警进行去重、分组、抑制、静默和路由等功能
&lt;ul>
&lt;li>&lt;strong>分组(Grouping)&lt;/strong>: 将相似告警合并为单个告警通知的机制 在系统因大面积故障而出发告警潮时 分组机制能避免用户被大量的告警噪声淹没 进行导致关键信息的隐没&lt;/li>
&lt;li>&lt;strong>抑制(Inhibition)&lt;/strong>: 系统中某个组件或服务故障而出发告警通知后 那些依赖于该组件或服务的其它组件或服务可能也会因此而触发告警 抑制便是避免类似的级联告警的一种特性 从而让用户能将精力集中于真正的故障所在&lt;/li>
&lt;li>&lt;strong>静默(Slience)&lt;/strong>: 是指在一个特定的时间窗口内 即便接收到告警通知 Alertmanager也不会真正向用户发送告警信息的行为 通常 在系统例行维护期间 需要激活告警系统的静默特性&lt;/li>
&lt;li>&lt;strong>路由(Route)&lt;/strong>: 用于配置Alertmanager如何处理传入的特定类型的告警通知 其基本逻辑是根据路由匹配规则的匹配结果来确定处理当前告警通知的路径和行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="告警规则">告警规则&lt;/h3>
&lt;ul>
&lt;li>类似于记录规则 有着类似或相关联功能的告警规则同样可以组织为group 从而为规则名称提供&lt;strong>名称空间&lt;/strong> 一个组内的每个告警必须有个名称 且在该组内必须唯一
&lt;ul>
&lt;li>alert: 告警规则的名称&lt;/li>
&lt;li>expr: 基于PromQL表达式的告警触发条件(布尔表达式) 用于计算是否有时间序列可以满足该条件 可以使用由Recording rule定义的指标&lt;/li>
&lt;li>for: 控制在出发告警之前 测试表达式的值必须为true的时长
&lt;ul>
&lt;li>表达式为true 但其持续时间为能满足for定义的时长时 相关的告警状态为pending状态&lt;/li>
&lt;li>满足该时长之后 相关的告警将被触发 并转为firing状态&lt;/li>
&lt;li>表达式的值为false时 告警将处于inactive状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>labels: 告警规则被激活时 相关时间序列上的所有标签都会添加到生成告警示例上 而labels则允许用户在告警上附加其它自定义的标签 该类标签值支持&lt;strong>模版化&lt;/strong>
&lt;ul>
&lt;li>告警名称及其标签则为告警的标识 类似于时间序列的标识机制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>annotations: 附加在告警之上的注解信息 其格式类似于标签 但不能被用于标识告警实例 经常用于存储告警摘要 且其值支持模版化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="告警路由">告警路由&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">[ receiver&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;string&amp;gt; ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># The labels by which incoming alerts are grouped together. For example,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># multiple alerts coming in for cluster=A and alertname=LatencyHigh would&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># be batched into a single group.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c">#&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># To aggregate by all possible labels use the special value &amp;#39;...&amp;#39; as the sole label name, for example:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># group_by: [&amp;#39;...&amp;#39;]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># This effectively disables aggregation entirely, passing through all&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># alerts as-is. This is unlikely to be what you want, unless you have&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># a very low alert volume or your upstream notification system performs&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># its own grouping.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 分组时使用的标签 默认情况下 所有的告警都组织在一起 而一旦指定分组标签 则Alertmanager将按这些标签进行分组&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">[ group_by&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;[&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;labelname&amp;gt;, ... &amp;#39;]&amp;#39; ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># Whether an alert should continue matching subsequent sibling nodes.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">[ continue&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;boolean&amp;gt; | default = false ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># DEPRECATED: Use matchers below.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># A set of equality matchers an alert has to fulfill to match the node.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">match&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">[ &amp;lt;labelname&amp;gt;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;labelvalue&amp;gt;, ... ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># DEPRECATED: Use matchers below.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># A set of regex-matchers an alert has to fulfill to match the node.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">match_re&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nt">[ &amp;lt;labelname&amp;gt;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;regex&amp;gt;, ... ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># A list of matchers that an alert has to fulfill to match the node.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">matchers&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">&amp;lt;matcher&amp;gt; ... ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># How long to initially wait to send a notification for a group&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># of alerts. Allows to wait for an inhibiting alert to arrive or collect&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># more initial alerts for the same group. (Usually ~0s to few minutes.)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 发出一组告警通知的初始等待时长 允许等待一个抑制告警到达或收集属于同一组的更多初始告警 通常是0至数分钟&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">[ group_wait&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;duration&amp;gt; | default = 30s ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># How long to wait before sending a notification about new alerts that&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># are added to a group of alerts for which an initial notification has&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># already been sent. (Usually ~5m or more.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 发送关于新告警的消息之前 需要等待多久 新告警将被添加到已经发送了初始通知的告警组中 一般在5分钟或以上&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">[ group_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;duration&amp;gt; | default = 5m ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># How long to wait before sending a notification again if it has already&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># been sent successfully for an alert. (Usually ~3h or more).&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 成功发送了告警后再次发送告警信息需要等待的时长 一般至少为3个小时&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">[ repeat_interval&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;duration&amp;gt; | default = 4h ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># Times when the route should be muted. These must match the name of a&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># mute time interval defined in the mute_time_intervals section.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># Additionally, the root node cannot have any mute times.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># When a route is muted it will not send any notifications, but&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># otherwise acts normally (including ending the route-matching process&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># if the `continue` option is not set.)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">mute_time_intervals&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">&amp;lt;string&amp;gt; ...]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># Times when the route should be active. These must match the name of a&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># time interval defined in the time_intervals section. An empty value&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># means that the route is always active.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># Additionally, the root node cannot have any active times.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># The route will send notifications only when active, but otherwise&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># acts normally (including ending the route-matching process&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># if the `continue` option is not set).&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">active_time_intervals&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">&amp;lt;string&amp;gt; ...]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># Zero or more child routes.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c"># 自路由配置&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nt">routes&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">&amp;lt;route&amp;gt; ... ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="prometheus-server高可用">Prometheus Server高可用&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.robustperception.io/scaling-and-federating-prometheus/" target="_blank" rel="noopener"
>Scaling and Federating Prometheus&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.robustperception.io/how-much-ram-does-prometheus-2-x-need-for-cardinality-and-ingestion/" target="_blank" rel="noopener"
>How much RAM does Prometheus 2.x need for cardinality and ingestion&lt;/a>&lt;/p>
&lt;h2 id="alertmanager高可用">Alertmanager高可用&lt;/h2>
&lt;p>&lt;a class="link" href="https://github.com/prometheus/alertmanager#high-availability" target="_blank" rel="noopener"
>alertmanager-HA&lt;/a>&lt;/p>
&lt;h2 id="promql-example">PromQL Example&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 待更新&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Docker</title><link>https://ilolicon.github.io/p/docker/</link><pubDate>Fri, 12 Jun 2020 12:10:00 +0800</pubDate><guid>https://ilolicon.github.io/p/docker/</guid><description>&lt;p>&lt;a class="link" href="https://docs.docker.com/" target="_blank" rel="noopener"
>&lt;img src="https://img.shields.io/badge/Docker-README-00A6ED"
loading="lazy"
alt="docker readme"
>&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.docker.com/" target="_blank" rel="noopener"
>&lt;img src="https://ilolicon.github.io/p/docker/icons/docker-icon.svg"
loading="lazy"
alt="docker"
>&lt;/a>&lt;/p>
&lt;h2 id="主机级虚拟化">主机级虚拟化&lt;/h2>
&lt;p>&lt;a class="link" href="https://virtual.51cto.com/art/201904/594481.htm" target="_blank" rel="noopener"
>Type1和Type2虚拟机管理程序区别&lt;/a>&lt;/p>
&lt;h3 id="type1">Type1&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Type1虚拟机管理程序直接在主机的物理硬件上运行 它被称为裸机虚拟机管理程序
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">它不必预先加载底层操作系统 通过直接访问底层硬件而无需其他软件&lt;span class="o">(&lt;/span>例如操作系统和设备驱动程序&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>VMware ESXi&lt;/li>
&lt;li>Microsoft Hyper-V服务器&lt;/li>
&lt;li>开源KVM&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h3 id="type2">Type2&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Type2虚拟机管理程序通常安装在现有操作系统之上 它称为托管虚拟机管理程序
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">因为它依赖于主机预先安装的操作系统来管理对CPU/内存/存储和网络资源的调用
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>VMware Fusion&lt;/li>
&lt;li>Oracle VM VirtualBox&lt;/li>
&lt;li>用于x86的Oracle VM Server&lt;/li>
&lt;li>Oracle Solaris Zones&lt;/li>
&lt;li>Parallels&lt;/li>
&lt;li>VMware Workstation&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h2 id="容器级虚拟化">容器级虚拟化&lt;/h2>
&lt;h3 id="namespace">Namespace&lt;/h3>
&lt;p>&lt;a class="link" href="https://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener"
>man-namespaces&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://lwn.net/Articles/531381/" target="_blank" rel="noopener"
>namespaces API&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">clone&lt;span class="o">()&lt;/span> &lt;span class="c1"># Creating a child in a new namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">setns&lt;span class="o">()&lt;/span> &lt;span class="c1"># Joining an existing namespace&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">unshare&lt;span class="o">()&lt;/span> &lt;span class="c1"># Leaving a namespace&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Linux Namespaces&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>namespace&lt;/th>
&lt;th>系统调用参数&lt;/th>
&lt;th>隔离内容&lt;/th>
&lt;th>内核版本&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>UTS&lt;/td>
&lt;td>CLONE_NEWUTS&lt;/td>
&lt;td>主机名和域名&lt;/td>
&lt;td>2.6.19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IPC&lt;/td>
&lt;td>CLONE_NEWIPC&lt;/td>
&lt;td>信号量/消息队列/共享内存&lt;/td>
&lt;td>2.6.19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PID&lt;/td>
&lt;td>CLONE_NEWPID&lt;/td>
&lt;td>进程编号&lt;/td>
&lt;td>2.6.24&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Network&lt;/td>
&lt;td>CLONE_NEWNET&lt;/td>
&lt;td>网络设备/网络栈/端口等&lt;/td>
&lt;td>2.6.29&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Mount&lt;/td>
&lt;td>CLONE_NEWNS&lt;/td>
&lt;td>挂载点(文件系统)&lt;/td>
&lt;td>2.4.19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>User&lt;/td>
&lt;td>CLONE_NEWUSER&lt;/td>
&lt;td>用户和用户组&lt;/td>
&lt;td>3.8&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="control-groups">Control Groups&lt;/h3>
&lt;p>&lt;a class="link" href="https://man7.org/linux/man-pages/man7/cgroups.7.html" target="_blank" rel="noopener"
>man-cgroups&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://tech.meituan.com/2015/03/31/cgroups.html" target="_blank" rel="noopener"
>linux资源管理之cgroups简介&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cgroups是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制 可以对cpu/内存等资源实现精细化的控制
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroups 的全称是control groups
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cgroups为每种可以控制的资源定义了一个子系统 典型的子系统介绍如下
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>blkio 块设备IO&lt;/li>
&lt;li>cpu CPU&lt;/li>
&lt;li>cpuacct CPU资源使用报告&lt;/li>
&lt;li>cpuset 多处理器平台上的CPU集合(按核/按比例)&lt;/li>
&lt;li>devices 设备访问&lt;/li>
&lt;li>freezer 挂起或恢复任务&lt;/li>
&lt;li>memory 内存用量及报告&lt;/li>
&lt;li>perf_event 对cgroup中的任务进行统一性能测试&lt;/li>
&lt;li>net_cls cgroup中的任务创建的数据报文的类别标识符&lt;/li>
&lt;/ul>
&lt;h3 id="lxc">LXC&lt;/h3>
&lt;p>&lt;a class="link" href="https://www.redhat.com/zh/topics/containers/whats-a-linux-container" target="_blank" rel="noopener"
>whats-a-linux-container&lt;/a>&lt;/p>
&lt;ul>
&lt;li>LinuX Container
&lt;ul>
&lt;li>lxc-create(创建namespace)&lt;/li>
&lt;li>template(拉取所需发行版的仓库相关包进行安装)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="容器编排">容器编排&lt;/h3>
&lt;ul>
&lt;li>machine + swarm + docker compose(单机编排)&lt;/li>
&lt;li>mesos + marathon&lt;/li>
&lt;li>kubernetes(k8s)&lt;/li>
&lt;/ul>
&lt;h2 id="docker">Docker&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># docker 容器引擎的发展&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># LXC -&amp;gt; libcontainer -&amp;gt; runC&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-&amp;gt; libcontainer&lt;span class="o">(&lt;/span>docker研发的容器引擎 替换LXC&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-&amp;gt; runC&lt;span class="o">(&lt;/span>容器运行时环境标准 Docker将RunC捐赠给OCI作为OCI容器运行时标准的参考实现&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;a class="link" href="https://os.51cto.com/art/202110/687502.htm" target="_blank" rel="noopener"
>docker/containerd/runC分别是什么&lt;/a>&lt;/p>
&lt;h3 id="oci">OCI&lt;/h3>
&lt;p>&lt;a class="link" href="https://opencontainers.org/" target="_blank" rel="noopener"
>&lt;img src="https://ilolicon.github.io/p/docker/icons/opencontainers-icon.svg"
loading="lazy"
alt="Open Container Initiative"
>&lt;/a>&lt;/p>
&lt;p>Open Container Initiative&lt;/p>
&lt;ul>
&lt;li>由Linux基金会主导于2015年6月创立&lt;/li>
&lt;li>旨在围绕容器格式和运行时制定一个开放的工业化标准&lt;/li>
&lt;li>contains two specifications
&lt;ul>
&lt;li>the Runtime Specification (runtime-spec) 运行时标准(规范)&lt;/li>
&lt;li>the Image Specification (image-spec) 镜像格式标准(规范)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The Runtime Specification outlines how to run a &amp;ldquo;filesystem bundle&amp;rdquo; that is unpacked on disk&lt;/li>
&lt;li>At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle&lt;/li>
&lt;/ul>
&lt;h3 id="runc">runC&lt;/h3>
&lt;p>&lt;a class="link" href="https://github.com/opencontainers/runc" target="_blank" rel="noopener"
>runC&lt;/a>&lt;/p>
&lt;ul>
&lt;li>OCF: Open Container Format&lt;/li>
&lt;li>runC: runc is a CLI tool for spawning and running containers on Linux according to the OCI specification&lt;/li>
&lt;/ul>
&lt;h3 id="docker-architecture">docker architecture&lt;/h3>
&lt;p>&lt;a class="link" href="https://docs.docker.com/get-started/overview/#docker-architecture" target="_blank" rel="noopener"
>&lt;img src="https://ilolicon.github.io/p/docker/icons/architecture.svg"
loading="lazy"
alt="docker architecture"
>&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Client -&amp;gt; Daemon&lt;span class="o">(&lt;/span>REST API, over UNIX sockets or a network interface&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Registry -&amp;gt; Host&lt;span class="o">(&lt;/span>https/http&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Registry: 仓库名&lt;span class="o">(&lt;/span>repo name&lt;span class="o">)&lt;/span> + 标签&lt;span class="o">(&lt;/span>tag&lt;span class="o">)&lt;/span> 唯一标识一个镜像
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-&amp;gt; nginx:1.14.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-&amp;gt; nginx:latest&lt;span class="o">(&lt;/span>default 最新版&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Images: An image is a read-only template with instructions &lt;span class="k">for&lt;/span> creating a Docker container
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Images：静态的 不会运行
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Containers：动态 有生命周期 类似命令
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> /bin/ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - ls /etc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - ls /var
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Moby
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-ee &lt;span class="c1"># 企业版&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">docker-ce &lt;span class="c1"># 社区版&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="docker-objects">docker objects&lt;/h3>
&lt;p>&lt;a class="link" href="https://docs.docker.com/get-started/overview/#docker-objects" target="_blank" rel="noopener"
>docker objects&lt;/a>&lt;/p>
&lt;ul>
&lt;li>images&lt;/li>
&lt;li>containers&lt;/li>
&lt;li>networks&lt;/li>
&lt;li>volumes&lt;/li>
&lt;li>plugins&lt;/li>
&lt;li>other objects&lt;/li>
&lt;/ul>
&lt;h4 id="images">Images&lt;/h4>
&lt;ul>
&lt;li>An image is a read-only template with instructions for creating a Docker container&lt;/li>
&lt;li>Often, an image is based on another image, with some additional customization&lt;/li>
&lt;li>You might create your own images or you might only use those created by others and published in a registry&lt;/li>
&lt;/ul>
&lt;h4 id="containers">Containers&lt;/h4>
&lt;ul>
&lt;li>A container is a runnable instance of an image&lt;/li>
&lt;li>You can create/start/stop/move or delete a container using the Docker API or CLI&lt;/li>
&lt;li>You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state&lt;/li>
&lt;/ul>
&lt;h3 id="docker-install">docker install&lt;/h3>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener"
>Install Docker Engine&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://mirrors.aliyun.com/docker-ce/" target="_blank" rel="noopener"
>阿里云Mirrors docker-ce&lt;/a>&lt;/p>
&lt;h4 id="docker-cerepo">docker-ce.repo&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>docker-ce-stable&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">name&lt;/span>&lt;span class="o">=&lt;/span>Docker CE Stable - &lt;span class="nv">$basearch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">baseurl&lt;/span>&lt;span class="o">=&lt;/span>https://download.docker.com/linux/centos/&lt;span class="nv">$releasever&lt;/span>/&lt;span class="nv">$basearch&lt;/span>/stable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/stable&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">enabled&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">gpgcheck&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">gpgkey&lt;/span>&lt;span class="o">=&lt;/span>https://download.docker.com/linux/centos/gpg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="镜像加速">镜像加速&lt;/h4>
&lt;ul>
&lt;li>docker cn&lt;/li>
&lt;li>&lt;a class="link" href="https://help.aliyun.com/document_detail/60750.html" target="_blank" rel="noopener"
>阿里云官方镜像加速&lt;/a>&lt;/li>
&lt;li>中国科技大学&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/etc/docker/daemon.json
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 更换镜像下载仓库链接&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;registry-mirrors&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;系统分配前缀.mirror.aliyuncs.com &amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="docker-cli">docker cli&lt;/h3>
&lt;p>&lt;a class="link" href="https://docs.docker.com/reference/" target="_blank" rel="noopener"
>docekr-reference&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">docker --help
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># docker event state 涉及部分常用命令&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="docker-event-state">docker event state&lt;/h3>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/commandline/events/" target="_blank" rel="noopener"
>&lt;img src="https://ilolicon.github.io/p/docker/icons/docker-event-state.jpg"
width="975"
height="496"
srcset="https://ilolicon.github.io/p/docker/icons/docker-event-state_hu1fb588f0bea85f45f342114261d318d9_52218_480x0_resize_q75_box.jpg 480w, https://ilolicon.github.io/p/docker/icons/docker-event-state_hu1fb588f0bea85f45f342114261d318d9_52218_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="docker event state"
class="gallery-image"
data-flex-grow="196"
data-flex-basis="471px"
>&lt;/a>&lt;/p>
&lt;h3 id="docker-image">docker image&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Docker镜像含有启动容器所需的文件系统及其内容 因此 其用于创建并启动docker容器
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="docker-image-layer">docker image layer&lt;/h4>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/docker-base-image.png"
width="800"
height="600"
srcset="https://ilolicon.github.io/p/docker/icons/docker-base-image_hu2e660399b17286aa9ee92b351b0a326a_72247_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/docker-base-image_hu2e660399b17286aa9ee92b351b0a326a_72247_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="分层构建"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="320px"
>&lt;/p>
&lt;ul>
&lt;li>采用分层构建机制 最底层为bootfs 其它为rootfs
&lt;ul>
&lt;li>bootfs: 用于&lt;code>系统引导&lt;/code>的文件系统 包括&lt;code>bootloader&lt;/code>和&lt;code>kernel&lt;/code> 容器启动完成后会被卸载以节约内存资源&lt;/li>
&lt;li>rootfs: 位于bootfs之上 表现为docker容器的根文件系统
&lt;ul>
&lt;li>传统模式中 系统启动时 内核挂载rootfs时会首先将其挂载为&lt;code>只读&lt;/code>模式(自检) 完整性自检完成后将其重新挂载为读写模式&lt;/li>
&lt;li>docker中 rootfs由内核挂载为&lt;code>只读&lt;/code>模式 而后通过&lt;code>联合挂载&lt;/code>技术额外挂载一个&lt;code>可写&lt;/code>层&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>docker image layer
&lt;ul>
&lt;li>位与下层的镜像成为父镜像(parent image) 最底层的称为基础镜像(base image)&lt;/li>
&lt;li>最上层的为&lt;code>可读写&lt;/code>层 其下的均为&lt;code>只读&lt;/code>层&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/docker-image-layer.png"
width="651"
height="430"
srcset="https://ilolicon.github.io/p/docker/icons/docker-image-layer_hu698cd364b218f2ed2f564ab487df7ce9_26319_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/docker-image-layer_hu698cd364b218f2ed2f564ab487df7ce9_26319_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="docker image layer"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;h4 id="aufs">aufs&lt;/h4>
&lt;ul>
&lt;li>Advanced Mult-Layered Unification Filesystem 高级多层统一文件系统&lt;/li>
&lt;li>用于为Linux文件系统实现&lt;code>联合挂载&lt;/code>&lt;/li>
&lt;li>aufs是之前UnionFS的重新实现 2006年由Junjiro Okajima开发&lt;/li>
&lt;li>Docekr最初使用aufs作为容器文件系统层 它目前仍作为存储后端之一来支持&lt;/li>
&lt;li>aufs的竞争产品是overlayfs 后者自从3.18版本开始被合并到Linux内核&lt;/li>
&lt;li>docker的分层镜像 除aufs之外 docker还支持btrfs/devicemapper/vfs等
&lt;ul>
&lt;li>Ubuntu系统下 docekr默认Ubuntu的aufs 而在CentOS7上 用的是devicemapper(新版默认使用overlay2)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="docekr-registry">docekr registry&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">启动容器时 docker daemon 会试图从本地获取相关的镜像 本地镜像不存在时 其将从Registry中下载该镜像并保存到本地
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Registry用于保存docker镜像 包括镜像的层次结构和元数据&lt;/li>
&lt;li>用户可以自建Registry 也可以使用官方的Docker Hub&lt;/li>
&lt;li>分类
&lt;ul>
&lt;li>Sponsor Registry: 第三方的registry 供客户和Docker社区使用(捐赠者)&lt;/li>
&lt;li>Mirror Registry: 第三方的registry 只让客户使用(云)&lt;/li>
&lt;li>Vendor Registry: 由发布Docker镜像的供应商提供的registry(redhat)&lt;/li>
&lt;li>Private Registry: 通过设有防火墙和额外安全层的私有实体提供的registry(自建)
&lt;ul>
&lt;li>&lt;a class="link" href="https://hub.docker.com/_/registry" target="_blank" rel="noopener"
>docker-registry/docker-distribution&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://goharbor.io/" target="_blank" rel="noopener"
>harbor&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/docker-registry.png"
width="1001"
height="516"
srcset="https://ilolicon.github.io/p/docker/icons/docker-registry_hua933c1d1f3b2ebd39d6af526d8740ae9_269181_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/docker-registry_hua933c1d1f3b2ebd39d6af526d8740ae9_269181_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="docker registry"
class="gallery-image"
data-flex-grow="193"
data-flex-basis="465px"
>&lt;/p>
&lt;h4 id="registryrepository-and-index">registry(repository and index)&lt;/h4>
&lt;ul>
&lt;li>Repository
&lt;ul>
&lt;li>由某特定的docker镜像的&lt;code>所有迭代版本&lt;/code>组成的镜像仓库&lt;/li>
&lt;li>一个Registry中可以存在多个Repository
&lt;ul>
&lt;li>Repository可分为&lt;code>顶层仓库&lt;/code>和&lt;code>用户仓库&lt;/code>&lt;/li>
&lt;li>用户仓库名称格式为&lt;code>用户名/仓库名&lt;/code> =&amp;gt; &lt;code>ilolicon/nginx&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>每个仓库可以包含多个Tag(标签) 每个标签对应一个镜像&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Index
&lt;ul>
&lt;li>维护用户账户/镜像的校验以及公共命名空间的信息&lt;/li>
&lt;li>相当于为Registry提供一个完成用户认证等功能的检索接口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="docker-hub">docker hub&lt;/h4>
&lt;p>&lt;a class="link" href="https://docs.docker.com/docker-hub/" target="_blank" rel="noopener"
>DockerHub&lt;/a>&lt;/p>
&lt;p>Docker Hub provides the following major features:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://docs.docker.com/docker-hub/repos/" target="_blank" rel="noopener"
>Repositories&lt;/a>: Push and pull container images&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.docker.com/docker-hub/orgs/" target="_blank" rel="noopener"
>Teams &amp;amp; Organizations&lt;/a>: Manage access to private repositories of container images&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.docker.com/docker-hub/official_images/" target="_blank" rel="noopener"
>Docker Official Images&lt;/a>: Pull and use high-quality container images provided by Docker&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.docker.com/docker-hub/publish/" target="_blank" rel="noopener"
>Docker Verified Publisher Images&lt;/a>: Pull and use high- quality container images provided by external vendors&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.docker.com/docker-hub/builds/" target="_blank" rel="noopener"
>Builds&lt;/a>: Automatically build container images from GitHub and Bitbucket and push them to Docker Hub&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.docker.com/docker-hub/webhooks/" target="_blank" rel="noopener"
>Webhooks&lt;/a>: Trigger actions after a successful push to a repository to integrate Docker Hub with other services&lt;/li>
&lt;/ul>
&lt;h4 id="docker-pull">docker pull&lt;/h4>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/commandline/pull/" target="_blank" rel="noopener"
>pull-commandline&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://quay.io/" target="_blank" rel="noopener"
>quay.io&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ docker pull &amp;lt;registry&amp;gt;&lt;span class="o">[&lt;/span>:port&lt;span class="o">]&lt;/span>/&lt;span class="o">[&lt;/span>&amp;lt;namespace&amp;gt;/&lt;span class="o">]&lt;/span>&amp;lt;name&amp;gt;:&amp;lt;tag&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># e.g:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># registry: quay.io&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># port: 443(没指定 默认)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># namespace: coreos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># name: flannel(repostory名称)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># tag: v0.15.1-arm64 指定版本&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker pull quay.io/coreos/flannel:v0.15.1-arm64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Namespace&lt;/th>
&lt;th>Examples(&amp;lt;namespace/name&amp;gt;)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>organization&lt;/td>
&lt;td>redhat/kubernetes google/kubernetes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>login(user name)&lt;/td>
&lt;td>alice/application ilolicon/application&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>role&lt;/td>
&lt;td>devel/database test/database prod/database&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="镜像的相关操作">镜像的相关操作&lt;/h4>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/docker-image-create.png"
width="1330"
height="778"
srcset="https://ilolicon.github.io/p/docker/icons/docker-image-create_hu35c6b1faa4899c64f224a792974bf729_550128_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/docker-image-create_hu35c6b1faa4899c64f224a792974bf729_550128_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="docker image create"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="410px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>镜像的生成途径&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener"
>Dockerfile&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.docker.com/engine/reference/commandline/commit/" target="_blank" rel="noopener"
>基于容器制作&lt;/a>&lt;/li>
&lt;li>Docekr Hub automated builds(仍是基于Dockerfile)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>另一种镜像分发方式&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://docs.docker.com/engine/reference/commandline/save/" target="_blank" rel="noopener"
>docker-save&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.docker.com/engine/reference/commandline/load/" target="_blank" rel="noopener"
>docker-load&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="容器虚拟化网络">容器虚拟化网络&lt;/h3>
&lt;h4 id="容器虚拟化网络概述">容器虚拟化网络概述&lt;/h4>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/hukey/p/14062579.html" target="_blank" rel="noopener"
>容器虚拟化网络&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">OVS: Open VSwitch
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SDN
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Overlay Network&lt;span class="o">(&lt;/span>叠加网络&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># docker默认的三种网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>ilolicon@master ~&lt;span class="o">]&lt;/span>$ docker network ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NETWORK ID NAME DRIVER SCOPE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">78fa953ed316 bridge bridge &lt;span class="nb">local&lt;/span> &lt;span class="c1"># 桥接 默认NAT桥&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8ec55273feb2 host host &lt;span class="nb">local&lt;/span> &lt;span class="c1"># 让容器直接使用宿主机的网络名称空间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9081fe29a218 none null &lt;span class="nb">local&lt;/span> &lt;span class="c1"># 只有lo接口 没有其他网卡&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>ilolicon@master ~&lt;span class="o">]&lt;/span>$ yum -y install bridge-utils
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>ilolicon@master ~&lt;span class="o">]&lt;/span>$ brctl show
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/four-network-container-archetypes.png"
width="921"
height="563"
srcset="https://ilolicon.github.io/p/docker/icons/four-network-container-archetypes_hu5fe812ea1b5552a81ec2413a76585961_183707_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/four-network-container-archetypes_hu5fe812ea1b5552a81ec2413a76585961_183707_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Four network container archetypes"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="392px"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.docker.com/network/" target="_blank" rel="noopener"
>docker-docs:network overview&lt;/a>&lt;/p>
&lt;ul>
&lt;li>Closed Container&lt;/li>
&lt;li>Bridged Container(NAT桥接网络 默认)&lt;/li>
&lt;li>Joined Container(联盟式容器网络 相对隔离 只是共享同一个网络名称空间)&lt;/li>
&lt;li>Open Container(开放式容器网络 共享宿主机网络名称空间)&lt;/li>
&lt;/ul>
&lt;h4 id="bridged-containers">Bridged Containers&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Bridged Containers可以为docker run命令使用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># &amp;#34;--hostname HOSTNAME&amp;#34; 选项为容器指定主机名&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --rm --net bridge --hostname cloudnative.ilolicon.com busybox:latest hostname
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># &amp;#34;--dns DNS_SERVER_IP&amp;#34; 选项能够为容器指定所使用的dns服务器地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --rm --dns 8.8.8.8 --dns 8.8.4.4 busybox:latest nslookup docker.com
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># &amp;#34;--add-host HOSTNAME:IP&amp;#34; 选项能够为容器指定本地主机名解析项&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --rm --dns 172.16.0.1 --add-host &lt;span class="s2">&amp;#34;docker.com:172.16.0.100&amp;#34;&lt;/span> busybox:latest cat /etc/hosts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h5 id="opening-inbound-communication--expose">Opening Inbound Communication / Expose&lt;/h5>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-p选项的使用格式
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将指定的容器端口&amp;lt;containerPort&amp;gt; 映射至主机所有地址的一个动态端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-p &amp;lt;containerPort&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将指定的容器端口&amp;lt;containerPort&amp;gt; 映射至指定的主机端口&amp;lt;hostPort&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-p &amp;lt;hostPort&amp;gt;:&amp;lt;containerPort&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将指定的容器端口&amp;lt;containerPort&amp;gt; 映射至主机指定&amp;lt;ip&amp;gt;的动态端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-p &amp;lt;ip&amp;gt;::&amp;lt;containerPort&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 将指定的容器端口&amp;lt;containerPort&amp;gt; 映射至主机指定&amp;lt;ip&amp;gt;的端口&amp;lt;hostPort&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-p &amp;lt;ip&amp;gt;:&amp;lt;hostPort&amp;gt;:&amp;lt;containerPort&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2">&amp;#34;动态端口&amp;#34;&lt;/span> 指随机端口 具体的映射结果可使用docker port命令查看
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Expose端口 还可以参考 -P 选项：暴露容器内部已指定的端口
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="joined-container">Joined Container&lt;/h4>
&lt;ul>
&lt;li>联盟式容器是指使用某个已存在容器的网络接口的容器 接口被联盟内的各容器共享使用(NTS Network IPC)&lt;/li>
&lt;li>联盟式容器彼此间虽然共享同一个网络名称空间 但其它内部名称空间如: User/Mount等还是隔离的&lt;/li>
&lt;li>联盟式容器彼此间存在端口冲突的可能性 使用此种模式的网络模型情况
&lt;ul>
&lt;li>多个容器上的程序需要程序loopback接口互相通信&lt;/li>
&lt;li>对某已存的容器的网络属性进行监控&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建一个监听于2222端口的http服务容器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --name t1 -it --rm busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/ &lt;span class="c1"># ifconfig&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建一个联盟式容器(--network指定使用t1的网络名称空间) 并查看其监听的端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --name t2 -it --rm --network container:t1 busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/ &lt;span class="c1"># ifconfig&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="open-container">Open Container&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --network 指定 host&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 直接使用宿主机的网络名称空间 无需再Expose端口&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --rm -it --network host busybox
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="closed-container">Closed Container&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --network none&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --rm -it --network none busybox
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="自定义docker0桥的网络信息">自定义docker0桥的网络信息&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 编辑 /etc/docker/daemon.json 配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;bip&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;192.168.1.5/24&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;fixed-cidr&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;10.20.0.0/16&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;fixed-cidr-v6&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;2001:db8::/64&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;mtu&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;1500&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;default-gateway&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;10.20.1.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;default-gateway-v6&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;2001:db8:abcd::89&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;dns&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;10.20.1.2&amp;#34;&lt;/span>,&lt;span class="s2">&amp;#34;10.20.1.3&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 核心选项为bip 即bridge ip之意 &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 用于指定docker0桥自身的IP地址 其他选项可以通过此地址计算得出&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="使用tcp套接字">使用TCP套接字&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># dockerd守护进程的C/S 其默认仅监听Unix Socket格式的地址 /var/run/docker.sock&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果使用TCP套接字 需要修改 /etc/docekr/daemon.json 配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 也可向dockerd直接传递 &amp;#34;-H|--host&amp;#34;选项&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;hosts&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;tcp://0.0.0.0:2375&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;unix:///var/run/docker.sock&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># dockerd使用TCP监听0.0.0.0:2375之后 客户端可以远程执行CLI&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker -H x.x.x.x:2375 image ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker -H x.x.x.x:2375 ps -a
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="创建自定义网络">创建自定义网络&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 创建自定义网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker network create -d bridge --subnet &lt;span class="s2">&amp;#34;172.26.0.0/16&amp;#34;&lt;/span> --gateway &lt;span class="s2">&amp;#34;172.26.0.1&amp;#34;&lt;/span> mybr0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用自定义网络&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>ilolicon@master ~&lt;span class="o">]&lt;/span>$ docker run -it --rm --name t1 --network mybr0 busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/ &lt;span class="c1"># ifconfig&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">eth0 Link encap:Ethernet HWaddr 02:42:AC:1A:00:02
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> inet addr:172.26.0.2 Bcast:172.26.255.255 Mask:255.255.0.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="docker存储卷">docker存储卷&lt;/h3>
&lt;h4 id="why-data-volumes存储卷">Why Data Volumes(存储卷)&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Docker镜像由多个&lt;span class="s2">&amp;#34;只读层&amp;#34;&lt;/span>叠加而成
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">启动容器时 Docker会加载只读镜像层并在镜像栈顶部添加一个&lt;span class="s2">&amp;#34;读写层&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">如果运行中的容器修改了现有的一个已经存在的文件
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">那该文件将会从读写层下面的只读层复制到读写层 该文件的只读版本&lt;span class="s2">&amp;#34;仍然存在&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">只是已经被读写层中该文件的副本所隐藏 此即&lt;span class="s2">&amp;#34;写时复制(COW)&amp;#34;&lt;/span>机制
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/files-visible-to-a-container.png"
width="751"
height="423"
srcset="https://ilolicon.github.io/p/docker/icons/files-visible-to-a-container_hu5bf186c999f6f34c90c9ad0a7dba16dd_138845_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/files-visible-to-a-container_hu5bf186c999f6f34c90c9ad0a7dba16dd_138845_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="file-visible"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;ul>
&lt;li>关闭并重启容器 其数据不受影响 但删除Docker容器 则其更改将会全部丢失&lt;/li>
&lt;li>存在的问题
&lt;ul>
&lt;li>存储于联合文件系统中 不易于宿主机访问(效率低)&lt;/li>
&lt;li>容器间数据共享不便&lt;/li>
&lt;li>删除容器其数据会丢失&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解决方案: &amp;ldquo;&lt;strong>卷&lt;/strong>(volume)&amp;rdquo;
&lt;ul>
&lt;li>&lt;strong>卷&lt;/strong>是容器上的一个或多个&lt;strong>目录&lt;/strong> 此类目录可绕过联合文件系统 与宿主机上的某目录&lt;strong>绑定(关联)&lt;/strong>&lt;/li>
&lt;li>Volume于容器初始化之时即会创建 由base image提供的卷中的数据会于此期间完成复制&lt;/li>
&lt;li>Volume的初衷是独立于容器的生命周期实现数据持久化 因此删除容器之时既不会删除卷 也不会对哪怕未被引用的卷做垃圾回收操作(加选项可以)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/volume.png"
width="693"
height="192"
srcset="https://ilolicon.github.io/p/docker/icons/volume_huc6dd66b5d1fa365b97dd8d30d2bb4680_75141_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/volume_huc6dd66b5d1fa365b97dd8d30d2bb4680_75141_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="volume"
class="gallery-image"
data-flex-grow="360"
data-flex-basis="866px"
>&lt;/p>
&lt;ul>
&lt;li>卷为docker提供了独立于容器的数据管理机制
&lt;ul>
&lt;li>可以把&lt;strong>镜像&lt;/strong>想象成静态文件 -&amp;gt; 例如 &lt;strong>程序&lt;/strong>; 把卷类比为动态内容 -&amp;gt; 例如 &lt;strong>数据&lt;/strong>; 于是 镜像可以重用 而卷可以共享&lt;/li>
&lt;li>卷实现了&lt;strong>程序(镜像)&lt;/strong> 和 &lt;strong>数据(卷)&lt;/strong> 分离 以及 &lt;strong>程序(镜像)&lt;/strong> 和 &lt;strong>制作镜像的主机&lt;/strong> 分离; 用户制作镜像时无需再考虑镜像运行的容器所在的主机的环境&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/volume2.png"
width="932"
height="374"
srcset="https://ilolicon.github.io/p/docker/icons/volume2_hubb053bbe15fe56dbede9e549ddb24aef_129737_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/volume2_hubb053bbe15fe56dbede9e549ddb24aef_129737_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="volume2"
class="gallery-image"
data-flex-grow="249"
data-flex-basis="598px"
>&lt;/p>
&lt;h4 id="data-volumes">Data volumes&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Docekr有两种类型的卷 每种类型都在容器中存在一个挂载点 但在其宿主机上的位置有所不同
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Bind mount volume(绑定挂在卷)
&lt;ul>
&lt;li>a volume that points to a user-specified location on the host file system&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Docker-managed volume(Docker管理卷)
&lt;ul>
&lt;li>the Docker daemon creates managed volumes in a portion of the host&amp;rsquo;s file system that&amp;rsquo;s owned by Docker&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/data-volumes.png"
width="1317"
height="440"
srcset="https://ilolicon.github.io/p/docker/icons/data-volumes_hu4dfcbd12cf6b4d086e7fe173542ab64f_196844_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/data-volumes_hu4dfcbd12cf6b4d086e7fe173542ab64f_196844_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="data-volume"
class="gallery-image"
data-flex-grow="299"
data-flex-basis="718px"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 在容器中使用Volumes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 为docker run命令使用-v选项即可使用Volume&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Docker-managed volume&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --name t1 -v /data busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker inspect -f &lt;span class="o">{{&lt;/span>.Mounts&lt;span class="o">}}&lt;/span> t1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Bind-mount Volume&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it -v HOSTDIR:VOLUMEDIR --name t2 bustbox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker inspect -f &lt;span class="o">{{&lt;/span>.Mount&lt;span class="o">}}&lt;/span> t2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="sharing-volumes">Sharing volumes&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># There are tow ways to share volumes between containers&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 多个容器的卷使用同一个主机目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --name t1 -v /docker/volumes/v1:/data busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --name t2 -v /docker/volumes/v1:/data busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 复制使用其他容器的卷 为docker run命令使用 --volumes-from 选项&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --name t3 -v /docker/volumes/v1:/data busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --name t4 --volumes-from t3 busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果有多个容器需要共享网络名称空间(UTS Network IPC) 以及需要共享存储卷&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 可以 事先创建一个 基础容器 其他的容器都加入该容器的网络名称空间(Joined Container) 并且复制该容器使用的卷(--volumes-from)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --name infracon -it -v /data/infracon/volume:/data busybox
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run --name nginx --network container:infracon --volumes-from infracon -it nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run ... --network container:infracon --volumes-from infracon ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="dockerfile">Dockerfile&lt;/h2>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener"
>Dockerfile-reference&lt;/a>&lt;/p>
&lt;p>Dockerfile is nothing but the source code for building Docker images&lt;/p>
&lt;ul>
&lt;li>Docker can build images automatically by reading the instructions from a Dockerfile&lt;/li>
&lt;li>A Dockerfile is a &lt;code>text document&lt;/code> than contains all the commands a user could call on the command line to assemble an image&lt;/li>
&lt;li>Using &lt;code>docker build&lt;/code> users can create an automated build that executes several command-line instructions in succession&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ilolicon.github.io/p/docker/icons/docker-build.png"
width="490"
height="242"
srcset="https://ilolicon.github.io/p/docker/icons/docker-build_hu78e016fdb09837500502497ac9124888_91582_480x0_resize_box_3.png 480w, https://ilolicon.github.io/p/docker/icons/docker-build_hu78e016fdb09837500502497ac9124888_91582_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="build"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="485px"
>&lt;/p>
&lt;h3 id="dockerfile-format">Dockerfile Format&lt;/h3>
&lt;ul>
&lt;li>Format
&lt;ul>
&lt;li># Comment (注释)&lt;/li>
&lt;li>INSTRUCTION arguments (指令及其参数 通常一行一个执行 太长使用&lt;code>\&lt;/code>换行)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The instruction is not case-sensitive (指令大小写不敏感)
&lt;ul>
&lt;li>However, convention is for them to be UPPERCASE to distinguish them from arguments more easily (一般约定使用大写 和参数区分开)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Docker runs instructions in a Dockerfile in order (顺序执行)&lt;/li>
&lt;li>The first instruction must be &lt;code>FROM&lt;/code> in order to specify the Base Image from which you are building (第一个非指数行 必须为&lt;code>FROM&lt;/code>指令)&lt;/li>
&lt;/ul>
&lt;h3 id="dockerignore-file">.dockerignore file&lt;/h3>
&lt;ul>
&lt;li>Before the docker CLI sends the context to the docker daemon, it looks for a file named .dockerignore in the root directory of the context&lt;/li>
&lt;li>If this file exists, the CLI modifies the context to exclude files and directories than match patterns in it&lt;/li>
&lt;li>The CLI interprets the .dockerignore file as a newline-separated list of patterns similar to the file globs of Unix shells&lt;/li>
&lt;/ul>
&lt;h3 id="environment-replacement">Environment replacement&lt;/h3>
&lt;ul>
&lt;li>Environment variables (declared with the &lt;code>ENV&lt;/code> statement) can also be used in certain instructions as variables to be interpred by the Dockerfile&lt;/li>
&lt;li>Environment variables are notated in the Dockerfile either with $variable_name or ${variable_name}&lt;/li>
&lt;li>The ${variable_name} syntax also supports a few of the standard bash modifiers
&lt;ul>
&lt;li>${variable:-word} - 设置默认值 variable未设置或为空 则变量默认值为: word&lt;/li>
&lt;li>${variable:+word} - 和 ${variable:-word} 相反&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="docekrfile-instructions">Docekrfile Instructions&lt;/h3>
&lt;h4 id="from">FROM&lt;/h4>
&lt;ul>
&lt;li>&lt;code>FROM&lt;/code>指令是最重要的一个且必须为Docekrfile文件开篇的第一个非注释行 用于为镜像文件构建过程指定基准镜像 后续的指令运行于此基准镜像所提供的运行环境&lt;/li>
&lt;li>实践中 基准镜像可以是任何可用镜像文件 默认情况下 &lt;code>docekr build&lt;/code>会在docker主机上查找指定的镜像文件 在其不存在时 则会从Docker Hub Registry上拉取所需的镜像文件
&lt;ul>
&lt;li>如果找不到执行的镜像文件 &lt;code>docker build&lt;/code>会返回一个错误信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>FROM &amp;lt;repository&amp;gt;[:&amp;lt;tag&amp;gt;]&lt;/code> 或&lt;/li>
&lt;li>&lt;code>FROM &amp;lt;repository&amp;gt;@&amp;lt;digest&amp;gt;&lt;/code> @符号指定hash码 确保base image不会被篡改
&lt;ul>
&lt;li>&lt;code>&amp;lt;repository&amp;gt;&lt;/code> 指定作为 base image 的名称&lt;/li>
&lt;li>&lt;code>&amp;lt;tag&amp;gt;&lt;/code> base image 的标签 可选 省略时默认为latest&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="maintanierdeprecated">MAINTANIER(deprecated)&lt;/h4>
&lt;ul>
&lt;li>用于让Docekrfile制作者提供本人的详细信息&lt;/li>
&lt;li>Dockerfile并不限制MAINTANIER指令出现的位置 但推荐将其放置于&lt;code>FROM&lt;/code>指令后&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>MAINTANIER &amp;lt;author's detail&amp;gt;&lt;/code>
&lt;ul>
&lt;li>&lt;code>&amp;lt;author's detail&amp;gt;&lt;/code>可以是任何文本信息 但约定俗成地使用作者名称及其邮件地址&lt;/li>
&lt;li>&lt;code>MAINTANIER &amp;quot;ilolicon &amp;lt;97431110@qq.com&amp;gt;&amp;quot;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="label">LABEL&lt;/h4>
&lt;p>The LABEL instruction adds metadata to an image (可替换MAINTANIER 并可添加更多元数据信息)&lt;/p>
&lt;ul>
&lt;li>Syntax: &lt;code>LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code>&lt;/li>
&lt;li>The LABEL instruction adds metadata to an image&lt;/li>
&lt;li>A LABEL is a key-value pair&lt;/li>
&lt;li>To include spaces within a LABEL value, use quotes and backslashes as you would in command-line parsing&lt;/li>
&lt;li>An image can have more than one label&lt;/li>
&lt;li>You can specify multiple labels on a single line&lt;/li>
&lt;/ul>
&lt;h4 id="copy">COPY&lt;/h4>
&lt;ul>
&lt;li>用于从Docker主机复制文件至创建的新镜像文件&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>COPY &amp;lt;src&amp;gt; ... &amp;lt;dest&amp;gt;&lt;/code> 或&lt;/li>
&lt;li>&lt;code>COPY [&amp;quot;&amp;lt;src&amp;gt;&amp;quot;, ..., &amp;quot;&amp;lt;dest&amp;gt;&amp;quot;]&lt;/code>
&lt;ul>
&lt;li>&lt;code>&amp;lt;src&amp;gt;&lt;/code> 要复制的源文件或目录 支持使用通配符&lt;/li>
&lt;li>&lt;code>&amp;lt;dest&amp;gt;&lt;/code> 目标路径 即正在创建的image的文件系统路径 建议&lt;code>&amp;lt;dest&amp;gt;&lt;/code>使用绝对路径 否则&lt;code>COPY&lt;/code>指令则以WORKDIR为其起始路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意: 在路径中有空白符时 通常使用第二种格式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>文件复制准则
&lt;ul>
&lt;li>&lt;code>&amp;lt;src&amp;gt;&lt;/code>必须是build上下文中的路径 不能是其父目录中的文件&lt;/li>
&lt;li>如果&lt;code>&amp;lt;src&amp;gt;&lt;/code>是目录 则其内部文件或子目录会被递归复制 但是&lt;code>&amp;lt;src&amp;gt;&lt;/code>目录本身不会被复制&lt;/li>
&lt;li>如果指定多个&lt;code>&amp;lt;src&amp;gt;&lt;/code> 或在&lt;code>&amp;lt;src&amp;gt;&lt;/code>中使用了通配符 则&lt;code>&amp;lt;dest&amp;gt;&lt;/code>必须是一个目录 且必须以&lt;code>/&lt;/code>结尾&lt;/li>
&lt;li>如果&lt;code>&amp;lt;dest&amp;gt;&lt;/code>事先不存在 它将会被自动创建 这包括其父级目录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="add">ADD&lt;/h4>
&lt;ul>
&lt;li>&lt;code>ADD&lt;/code>指令类似于&lt;code>COPY&lt;/code>指令 ADD支持使用TAR文件和URL路径&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>ADD &amp;lt;src&amp;gt; ... &amp;lt;dest&amp;gt;&lt;/code> 或&lt;/li>
&lt;li>&lt;code>ADD [&amp;quot;&amp;lt;src&amp;gt;&amp;quot;, ..., &amp;quot;&amp;lt;dest&amp;gt;&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>操作准则
&lt;ul>
&lt;li>同&lt;code>COPY&lt;/code>指令&lt;/li>
&lt;li>URL
&lt;ul>
&lt;li>如果&lt;code>&amp;lt;src&amp;gt;&lt;/code>为URL且&lt;code>&amp;lt;dest&amp;gt;&lt;/code>不以&lt;code>/&lt;/code>结尾 则&lt;code>&amp;lt;src&amp;gt;&lt;/code>指定的文件将被下载并直接被创建为&lt;code>&amp;lt;dest&amp;gt;&lt;/code>&lt;/li>
&lt;li>如果&lt;code>&amp;lt;src&amp;gt;&lt;/code>为URL且&lt;code>&amp;lt;dest&amp;gt;&lt;/code>以&lt;code>/&lt;/code>结尾 则文件名URL指定的文件将被下载并保存为&lt;code>&amp;lt;dest&amp;gt;/&amp;lt;filename&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TAR
&lt;ul>
&lt;li>如果&lt;code>&amp;lt;src&amp;gt;&lt;/code>是一个本地系统上的压缩格式的tar文件 它将被展开为一个目录 其行为类似于&lt;code>tar -x&lt;/code>命令 然而 通道URL获取到的tar文件将不会自动展开&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果&lt;code>&amp;lt;src&amp;gt;&lt;/code>有多个 或其间接或直接使用了通配符 则&lt;code>&amp;lt;dest&amp;gt;&lt;/code>必须是一个以&lt;code>/&lt;/code>结尾的目录路径 如果&lt;code>&amp;lt;dest&amp;gt;&lt;/code>不以&lt;code>/&lt;/code>结尾 则其将被视为一个普通文件 &lt;code>&amp;lt;src&amp;gt;&lt;/code>的内容将被直接写入到&lt;code>&amp;lt;dest&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="workdir">WORKDIR&lt;/h4>
&lt;ul>
&lt;li>用于为Dockerfile中所有的&lt;code>RUN/CMD/ENTRYPOINT/COPY/ADD&lt;/code>指令设置工作目录&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>WORKDIR &amp;lt;dirpath&amp;gt;&lt;/code>
&lt;ul>
&lt;li>在Dockerfile中 &lt;code>WORKDIR&lt;/code>指令可以出现多次 其路径也可以为相对路径 不过其是相对此前一个&lt;code>WODKDIR&lt;/code>指令指定的路径&lt;/li>
&lt;li>另外 &lt;code>WORKDIR&lt;/code>也可调用由&lt;code>ENV&lt;/code>指令定义的变量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>e.g
&lt;ul>
&lt;li>&lt;code>WORKDIR /var/log&lt;/code>&lt;/li>
&lt;li>&lt;code>WORKDIR $STATEPATH&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="volume">VOLUME&lt;/h4>
&lt;ul>
&lt;li>用于在image中创建一个挂载点目录 以挂载Docker host上的卷或其他容器上的卷&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>VOLUME &amp;lt;mountpoint&amp;gt;&lt;/code> 或&lt;/li>
&lt;li>&lt;code>VOLUME [&amp;quot;&amp;lt;mountpoint&amp;gt;&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果挂载点目录路径下此前在文件存在 &lt;code>docker run&lt;/code>命令会在挂载完成后将此前的所有文件复制到新挂载的卷中&lt;/li>
&lt;/ul>
&lt;h4 id="expose">EXPOSE&lt;/h4>
&lt;ul>
&lt;li>用于为容器打开指定要监听的端口 以实现与外部通信&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>EXPOSE &amp;lt;port&amp;gt;[/&amp;lt;protocol&amp;gt;] [&amp;lt;port&amp;gt;[/protocol]...]&lt;/code>
&lt;ul>
&lt;li>&lt;code>&amp;lt;protocol&amp;gt;&lt;/code>用于指定传输层协议 可为tcp或udp二者之一 默认为TCP协议&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>EXPOSE&lt;/code>指令可一次指定多个端口
&lt;ul>
&lt;li>&lt;code>EXPOSE 11211/udp 11211/tcp&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="env">ENV&lt;/h4>
&lt;ul>
&lt;li>用于为镜像定义所需的环境变量 并可被Dockerfile文件中位与其后的其它指令(如&lt;code>ENV/ADD/COPY&lt;/code>等)所调用&lt;/li>
&lt;li>调用格式为 $variable_name 或 ${variable_name}&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code> 或&lt;/li>
&lt;li>&lt;code>ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第一种格式中: &lt;code>&amp;lt;key&amp;gt;&lt;/code>之后的所有内容均会被视作其&lt;code>&amp;lt;value&amp;gt;&lt;/code>的组成部分 因此 一次只能设置一个变量&lt;/li>
&lt;li>第二种格式中: 可以一次设置多个变量 每个变量为一个&lt;code>&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code>的键值对 如果&lt;code>&amp;lt;value&amp;gt;&lt;/code>中包含空格 可以以反斜线&lt;code>\&lt;/code>进行转义 也可以通过对&lt;code>&amp;lt;value&amp;gt;&lt;/code>加引号进行标识 另外 反斜线也用于续行&lt;/li>
&lt;li>定义多个变量时 建议使用第二种方式 以便在同一层中完成所有功能&lt;/li>
&lt;/ul>
&lt;h4 id="run">RUN&lt;/h4>
&lt;ul>
&lt;li>用于指定&lt;code>docker build&lt;/code>过程中运行的程序 其可以是任何命令(基于base image提供)&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>RUN &amp;lt;command&amp;gt;&lt;/code> 或&lt;/li>
&lt;li>&lt;code>RUN [&amp;quot;&amp;lt;executable&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param2&amp;gt;&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第一种格式中 &lt;code>&amp;lt;command&amp;gt;&lt;/code> 通常是一个shell命令 且以&lt;code>/bin/sh -c&lt;/code>来运行它 这意味着此进程在容器中的PID不是1 不能接收Unix信号 因此 当使用&lt;code>docker stop &amp;lt;container&amp;gt;&lt;/code>命令停止容器时 此进程接收不到SIGTERM信号&lt;/li>
&lt;li>第二种语法格式中的参数是一个JSON格式的数组 其中&lt;code>&amp;lt;executable&amp;gt;&lt;/code>为要运行的命令 后面的&lt;code>&amp;lt;paramN&amp;gt;&lt;/code>为传递给命令的选项或参数 然而 此种格式指定的命令不会以&lt;code>/bin/sh -c&lt;/code>来发起 因此常见的shell操作如变量替换以及通配符&lt;code>? *等&lt;/code>替换将不会进行 不过如果要运行的命令依赖于此shell特性的话 可以将其替换为类似下面的格式
&lt;ul>
&lt;li>&lt;code>RUN [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;&amp;lt;executable&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param1&amp;gt;&amp;quot;]&lt;/code>&lt;/li>
&lt;li>Json数组中 注意要使用&lt;strong>双引号&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="cmd">CMD&lt;/h4>
&lt;ul>
&lt;li>类似于&lt;code>RUN&lt;/code>指令 &lt;code>CMD&lt;/code>指令也可用于运行任何命令或应用程序 不过 二者的运行时间点不同
&lt;ul>
&lt;li>&lt;code>RUN&lt;/code>指令运行于映像文件构建过程中 而&lt;code>CMD&lt;/code>指令运行于基于Dockerfile构建出的新映像文件启动一个容器时&lt;/li>
&lt;li>&lt;code>CMD&lt;/code>指令的首要目的在于为启动的容器指定&lt;code>默认&lt;/code>要运行的程序 且其运行结束后 容器也将终止 不过&lt;code>CMD&lt;/code>指定的命令可以被&lt;code>docker run&lt;/code>的命令行选项所覆盖&lt;/li>
&lt;li>在Docekrfile中 可以存在多个&lt;code>CMD&lt;/code>指令 但仅最后一个会生效&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>CMD &amp;lt;command&amp;gt;&lt;/code> 或&lt;/li>
&lt;li>&lt;code>CMD [&amp;quot;&amp;lt;executable&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param2&amp;gt;&amp;quot;]&lt;/code> 或&lt;/li>
&lt;li>&lt;code>CMD [&amp;quot;&amp;lt;param1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param2&amp;gt;&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>前两种语法格式的意义同&lt;code>RUN&lt;/code>&lt;/li>
&lt;li>都三种则用于为&lt;code>ENTRYPOINT&lt;/code>指令提供默认参数&lt;/li>
&lt;/ul>
&lt;h4 id="entrypoint">ENTRYPOINT&lt;/h4>
&lt;ul>
&lt;li>类似&lt;code>CMD&lt;/code>指令的功能 用于为容器指定默认运行程序 从而使得容器像是一个单独的可执行程序&lt;/li>
&lt;li>与&lt;code>CMD&lt;/code>不同的是 由&lt;code>ENTRYPOINT&lt;/code>启动的程序不会被&lt;code>docker run&lt;/code>命令行指定的参数所覆盖 而且 这些命令行参数会被当作参数传递给&lt;code>ENTRYPOINT&lt;/code>指令指定的程序
&lt;ul>
&lt;li>不过 &lt;code>docker run&lt;/code>命令的&lt;code>--entrypoint&lt;/code>选项的参数 可以覆盖&lt;code>ENTRYPOINT&lt;/code>指令指定的程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>ENTRYPOINT &amp;lt;command&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>ENTRYPOINT [&amp;quot;&amp;lt;executable&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;param2&amp;gt;&amp;quot;]&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>docker run&lt;/code>命令传入的命令参数会覆盖&lt;code>CMD&lt;/code>指令的内容 并且附加到&lt;code>ENTRYPOINT&lt;/code>命令最后作为其参数使用&lt;/li>
&lt;li>Dockerfile文件中也可以存在多个&lt;code>ENTRYPOINT&lt;/code>指令 但仅有最后一个会生效&lt;/li>
&lt;/ul>
&lt;p>Tips: 使用&lt;code>ENTRYPOINT&lt;/code>解决配置文件&lt;strong>环境变量&lt;/strong>使用问题&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 问题: nginx(或其他程序)配置文件有许多需要修改的配置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 比如: root_dir / listen_ip / listen_port 等等 &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用容器的情况下 如何更优的解决该问题?&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>docker-entrypoint.sh&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://github.com/docker-library/mysql/blob/master/5.7/docker-entrypoint.sh" target="_blank" rel="noopener"
>refer:MySQL dokcer-entrypoint.sh&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#!/bin/sh
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 根据变量(环境变量/自定义变量)生成配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 需要修改的 传入环境变量的方式 比如: APP_ENV: TEST|PROD|DEV&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># docker run -d --name=ngx --env PORT=8080 --env XX=XX --rm ngx:v1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">IP&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>ip address show dev eth0 &lt;span class="p">|&lt;/span> awk &lt;span class="s1">&amp;#39;/inet /{split($2, ip, &amp;#34;/&amp;#34;);print ip[1]}&amp;#39;&lt;/span>&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cat &amp;gt; /etc/nginx/conf.d/www.conf &lt;span class="s">&amp;lt;&amp;lt; EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">server {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> server_name ${HOSTNAME};
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> listen ${IP:-0.0.0.0}:${PORT:-80};
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> root ${NGX_DOC_ROOT:-/usr/share/nginx/html/};
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Dockerfile CMD指定的参数($@) 取代当前shell 成为 main-process&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">exec&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$@&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Dockerfile&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> nginx:1.14-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">LABEL&lt;/span> &lt;span class="nv">maintainer&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;ilolicon &amp;lt;97431110@qq.com&amp;gt;&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENV&lt;/span> &lt;span class="nv">NGX_DOC_ROOT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;/data/www/html/&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> index.html &lt;span class="nv">$NGX_DOC_ROOT&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ADD&lt;/span> docker-entrypoint.sh /bin/&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/usr/sbin/nginx&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;-g&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;daemon off&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="c"># CMD指令参数 传递给docker-entrypoint.sh脚本 脚本用$@获取全部参数&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">ENTRYPOINT&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;/bin/docker-entrypoint.sh&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="user">USER&lt;/h4>
&lt;ul>
&lt;li>用于指定运行image时或运行Dockerfile中任何&lt;code>RUN CMD 或 ENTRYPOINT&lt;/code>指令指定的程序时的用户名或UID&lt;/li>
&lt;li>默认情况下 container的运行身份为root用户&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>USER &amp;lt;UID&amp;gt;|&amp;lt;UserName&amp;gt;&lt;/code>&lt;/li>
&lt;li>需要注意的是 &lt;code>&amp;lt;UID&amp;gt;&lt;/code>可以为任意数字 但实践中其必须为&lt;code>/etc/passwd&lt;/code>(容器中)中某用户的有效UID 否则&lt;code>docker run&lt;/code>命令将运行失败&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="healthcheck">HEALTHCHECK&lt;/h4>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="noopener"
>HEALTHCHECK&lt;/a>&lt;/p>
&lt;ul>
&lt;li>The &lt;code>HEALTHCHECK&lt;/code> instruction tells Docker how to test a container to check that it is still working&lt;/li>
&lt;li>This can detect cases such as a web server that is stuck in an infinite loop and unable to handle new connections, even though the server process is still running&lt;/li>
&lt;li>The HEALTHCHECK instruction has two forms
&lt;ul>
&lt;li>&lt;code>HEALTHCHECK [OPTIONS] CMD command&lt;/code> (check container health by running a command inside the container)&lt;/li>
&lt;li>&lt;code>HEALTHCHECK NONE&lt;/code> (disable any healthcheck inherited from the base image)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The options that can appear before CMD are:
&lt;ul>
&lt;li>&amp;ndash;interval=DURATION (default: 30s)&lt;/li>
&lt;li>&amp;ndash;timeout=DURATION (default: 30s)&lt;/li>
&lt;li>&amp;ndash;start-period=DURATION (default: 0s) - 多少秒之后开始检测 等待container init的时间&lt;/li>
&lt;li>&amp;ndash;retries=N (default: 3)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The command’s exit status indicates the health status of the container. The possible values are:
&lt;ul>
&lt;li>0: success - the container is healthy and ready for use&lt;/li>
&lt;li>1: unhealthy - the container is not working correctly&lt;/li>
&lt;li>2: reserved - do not use this exit code - 预留 不要使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>For example
&lt;ul>
&lt;li>&lt;code>HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="shell">SHELL&lt;/h4>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/builder/#shell" target="_blank" rel="noopener"
>SHELL&lt;/a>&lt;/p>
&lt;ul>
&lt;li>The &lt;code>SHELL&lt;/code> instruction allows the default &lt;em>shell&lt;/em> used for the shell form of commands to be overridden&lt;/li>
&lt;li>The default shell on Linux is [&amp;quot;/bin/sh&amp;quot;, &amp;ldquo;-c&amp;rdquo;], and on Windows is [&amp;ldquo;cmd&amp;rdquo;, &amp;ldquo;/S&amp;rdquo;, &amp;ldquo;/C&amp;rdquo;]&lt;/li>
&lt;li>The &lt;code>SHELL&lt;/code> instruction must be written in JSON form in a Dockerfile
&lt;ul>
&lt;li>Syntax: SHELL [&amp;ldquo;executable&amp;rdquo;, &amp;ldquo;parameters&amp;rdquo;]&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The &lt;code>SHELL&lt;/code> instruction can appear multiple times&lt;/li>
&lt;li>Each &lt;code>SHELL&lt;/code> instruction overrides all previous &lt;code>SHELL&lt;/code> instructions, and affects all subsequent instruction&lt;/li>
&lt;/ul>
&lt;h4 id="stopsignal">STOPSIGNAL&lt;/h4>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/builder/#stopsignal" target="_blank" rel="noopener"
>STOPSIGNAL&lt;/a>&lt;/p>
&lt;ul>
&lt;li>The &lt;code>STOPSIGNAL&lt;/code> instruction sets the system call signal that will be sent to the container to exit&lt;/li>
&lt;li>This signal can be a signal name in the format &lt;code>SIG&amp;lt;NAME&amp;gt;&lt;/code>, for instance &lt;code>SIGKILL&lt;/code>, or an unsigned number that matches a position in the kernel’s syscall table, for instance &lt;code>9&lt;/code>
&lt;ul>
&lt;li>The default is &lt;code>SIGTERM&lt;/code> if not defined&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Syntax: &lt;code>STOPSIGNAL signal&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="arg">ARG&lt;/h4>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener"
>ARG&lt;/a>&lt;/p>
&lt;ul>
&lt;li>The ARG instruction defines a variable that users can pass at build-time to the builder with the docker build command using the &lt;code>--build-arg &amp;lt;varname&amp;gt;=&amp;lt;value&amp;gt;&lt;/code> flag&lt;/li>
&lt;li>If a user specifies a build argument that was not defined in the Dockerfile, the build outputs a warning
&lt;ul>
&lt;li>&lt;code>[Warning] One or more build-args [foo] were not consumed.&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Syntax: &lt;code>ARG &amp;lt;name&amp;gt;[=&amp;lt;default value&amp;gt;]&lt;/code>&lt;/li>
&lt;li>A Dockerfile may include one or more &lt;code>ARG&lt;/code> instructions&lt;/li>
&lt;li>An &lt;code>ARG&lt;/code> instruction can optionally include a default value:
&lt;ul>
&lt;li>&lt;code>ARG user1=someuser&lt;/code>&lt;/li>
&lt;li>&lt;code>ARG buildno=1&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>⚠️ &lt;strong>Warning&lt;/strong>
It is not recommended to use build-time variables for passing secrets like github keys, user credentials etc. Build-time variable values are visible to any user of the image with the &lt;code>docker history&lt;/code> command.&lt;/p>
&lt;p>Refer to the &lt;a class="link" href="https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information" target="_blank" rel="noopener"
>&amp;ldquo;build images with BuildKit&amp;rdquo;&lt;/a> section to learn about secure ways to use secrets when building images.&lt;/p>
&lt;h4 id="onbuild">ONBUILD&lt;/h4>
&lt;ul>
&lt;li>用于在Dockerfile中定义一个触发器&lt;/li>
&lt;li>Dockerfile用于build映像文件 此映像文件亦可作为base image被另一个Dockerfile用作&lt;code>FROM&lt;/code>指令的参数 并以之构建新的镜像文件&lt;/li>
&lt;li>在后面的这个Dockerfile中的&lt;code>FROM&lt;/code>指令在build过程中被执行时 将会&lt;strong>触发&lt;/strong>创建其base image的Dockerfile文件中的&lt;code>ONBUILD&lt;/code>指令定义的触发器&lt;/li>
&lt;li>Syntax
&lt;ul>
&lt;li>&lt;code>ONBUILD &amp;lt;INSTRUCTION&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>尽管任何指令都可以注册成为触发器指令 但&lt;code>ONBUILD&lt;/code>不能自我嵌套 且不会触发&lt;code>FROM&lt;/code>和&lt;code>MAINTAINER&lt;/code>指令&lt;/li>
&lt;li>使用包含&lt;code>ONBUILD&lt;/code>指令的Dockerfile构建的镜像应该使用特殊的标签
&lt;ul>
&lt;li>e.g: ruby:2.0-onbuild&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在&lt;code>ONBUILD&lt;/code>指令中使用&lt;code>ADD&lt;/code>或&lt;code>COPY&lt;/code>指令应该格外小心 因为新 构建过程的上下文在缺少指定的源文件时会失败&lt;/li>
&lt;/ul>
&lt;h2 id="docker资源限制">Docker资源限制&lt;/h2>
&lt;p>&lt;a class="link" href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="noopener"
>Limit a container&amp;rsquo;s resources&lt;/a>&lt;/p>
&lt;ul>
&lt;li>By default, a container has no resource constraints and can use as much of a given resource as the host’s kernel scheduler allows&lt;/li>
&lt;li>Docker provides ways to control how much memory, or CPU a container can use, setting runtime configuration flags of the &lt;code>docker run&lt;/code> command&lt;/li>
&lt;li>Many of these features require your kernel to support Linux capabilities
&lt;ul>
&lt;li>To check for support, you can use the &lt;code>docker info&lt;/code> command&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="oome">OOME&lt;/h3>
&lt;ul>
&lt;li>On Linux hosts, if the kernel detects that there is not enough memory to perform important system functions, it throws an &lt;code>OOME&lt;/code>, or &lt;code>Out Of Memory Exception&lt;/code>, and starts killing processes to free up memory
&lt;ul>
&lt;li>一旦发生OOME 任何进程都有可能被杀死 包括docker daemon在内&lt;/li>
&lt;li>为此 Docker特地调整了docker daemon的OOM优先级 以免它被内核&amp;quot;正法&amp;quot; 但容器优先级并为调整&lt;/li>
&lt;li>&lt;code>Memory Hogs&lt;/code> &lt;code>OOM_ADJ&lt;/code> &lt;code>OOM_SCORE&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="limit-a-containers-access-to-memory">Limit a container’s access to memory&lt;/h4>
&lt;ul>
&lt;li>Docker can enforce hard memory limits, which allow the container to use no more than a given amount of user or system memory&lt;/li>
&lt;li>or soft limits, which allow the container to use as much memory as it needs unless certain conditions are met, such as when the kernel detects low memory or contention on the host machine&lt;/li>
&lt;li>Some of these options have different effects when used alone or when more than one option is set&lt;/li>
&lt;li>Most of these options take a positive integer, followed by a suffix of &lt;code>b, k, m, g&lt;/code>, to indicate bytes, kilobytes, megabytes, or gigabytes&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Option&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>-m&lt;/code> or &lt;code>--memory=&lt;/code>&lt;/td>
&lt;td>The maximum amount of memory the container can use. If you set this option, the minimum allowed value is &lt;code>6m&lt;/code> (6 megabytes). That is, you must set the value to at least 6 megabytes.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--memory-swap *&lt;/code>&lt;/td>
&lt;td>The amount of memory this container is allowed to swap to disk. See &lt;a class="link" href="https://docs.docker.com/config/containers/resource_constraints/#--memory-swap-details" target="_blank" rel="noopener"
>&lt;code>--memory-swap&lt;/code> details&lt;/a>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--memory-swappiness&lt;/code>&lt;/td>
&lt;td>By default, the host kernel can swap out a percentage of anonymous pages used by a container. You can set &lt;code>--memory-swappiness&lt;/code> to a value between 0 and 100, to tune this percentage. See &lt;a class="link" href="https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details" target="_blank" rel="noopener"
>&lt;code>--memory-swappiness&lt;/code> details&lt;/a>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--memory-reservation&lt;/code>&lt;/td>
&lt;td>Allows you to specify a soft limit smaller than &lt;code>--memory&lt;/code> which is activated when Docker detects contention or low memory on the host machine. If you use &lt;code>--memory-reservation&lt;/code>, it must be set lower than &lt;code>--memory&lt;/code> for it to take precedence. Because it is a soft limit, it does not guarantee that the container doesn’t exceed the limit.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--kernel-memory&lt;/code>&lt;/td>
&lt;td>The maximum amount of kernel memory the container can use. The minimum allowed value is &lt;code>4m&lt;/code>. Because kernel memory cannot be swapped out, a container which is starved of kernel memory may block host machine resources, which can have side effects on the host machine and on other containers. See &lt;a class="link" href="https://docs.docker.com/config/containers/resource_constraints/#--kernel-memory-details" target="_blank" rel="noopener"
>&lt;code>--kernel-memory&lt;/code> details&lt;/a>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--oom-kill-disable&lt;/code>&lt;/td>
&lt;td>By default, if an out-of-memory (OOM) error occurs, the kernel kills processes in a container. To change this behavior, use the &lt;code>--oom-kill-disable&lt;/code> option. Only disable the OOM killer on containers where you have also set the &lt;code>-m/--memory&lt;/code> option. If the &lt;code>-m&lt;/code> flag is not set, the host can run out of memory and the kernel may need to kill the host system’s processes to free memory.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="--memory-swap">&amp;ndash;memory-swap&lt;/h4>
&lt;ul>
&lt;li>Using swap allows the container to write excess memory requirements to disk when the container has exhausted all the RAM that is available to it&lt;/li>
&lt;li>&lt;code>--memory-swap&lt;/code> is a modifier flag that only has meaning if &lt;code>--memory&lt;/code> is also set&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;code>--memory-swap&lt;/code>&lt;/th>
&lt;th>&lt;code>--memory&lt;/code>&lt;/th>
&lt;th>功能&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>正数S&lt;/td>
&lt;td>正数M&lt;/td>
&lt;td>容器可用总空间为S 其中ram为M swap为(S-M) 若S=M 则无可用swap资源&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>正数M&lt;/td>
&lt;td>相当于未设置swap(unset)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>unset&lt;/td>
&lt;td>正数M&lt;/td>
&lt;td>若主机(Docker Host)启用了swap 则容器的可用swap为 2*M&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-1&lt;/td>
&lt;td>正数M&lt;/td>
&lt;td>若主机(Docker Host)启用了swap 则容器可使用最大至主机的所有swap空间的swap资源&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>⚠️ &lt;strong>注意:&lt;/strong> 在容器内使用free命令可以看到的swap空间 并不具有其所展示出的空间指示意义&lt;/p>
&lt;h3 id="cpu">CPU&lt;/h3>
&lt;p>&lt;a class="link" href="https://linux.cn/article-7325-1.html" target="_blank" rel="noopener"
>深入Linux的进程优先级&lt;/a>&lt;/p>
&lt;ul>
&lt;li>By default, each container’s access to the host machine’s CPU cycles is unlimited&lt;/li>
&lt;li>You can set various constraints to limit a given container’s access to the host machine’s CPU cycles&lt;/li>
&lt;li>Most users use and configure the &lt;a class="link" href="https://docs.docker.com/config/containers/resource_constraints/#configure-the-default-cfs-scheduler" target="_blank" rel="noopener"
>default CFS scheduler&lt;/a>&lt;/li>
&lt;li>You can also configure the &lt;a class="link" href="https://docs.docker.com/config/containers/resource_constraints/#configure-the-realtime-scheduler" target="_blank" rel="noopener"
>realtime scheduler&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h4 id="configure-the-default-cfs-scheduler">Configure the default CFS scheduler&lt;/h4>
&lt;p>The CFS is the Linux kernel CPU scheduler for normal Linux processes. Several runtime flags allow you to configure the amount of access to CPU resources your container has. When you use these settings, Docker modifies the settings for the container’s cgroup on the host machine.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Option&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>--cpus=&amp;lt;value&amp;gt;&lt;/code>&lt;/td>
&lt;td>Specify how much of the available CPU resources a container can use. For instance, if the host machine has two CPUs and you set &lt;code>--cpus=&amp;quot;1.5&amp;quot;&lt;/code>, the container is guaranteed at most one and a half of the CPUs. This is the equivalent of setting &lt;code>--cpu-period=&amp;quot;100000&amp;quot;&lt;/code> and &lt;code>--cpu-quota=&amp;quot;150000&amp;quot;&lt;/code>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--cpu-period=&amp;lt;value&amp;gt;&lt;/code>&lt;/td>
&lt;td>Specify the CPU CFS scheduler period, which is used alongside &lt;code>--cpu-quota&lt;/code>. Defaults to 100000 microseconds (100 milliseconds). Most users do not change this from the default. For most use-cases, &lt;code>--cpus&lt;/code> is a more convenient alternative.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--cpu-quota=&amp;lt;value&amp;gt;&lt;/code>&lt;/td>
&lt;td>Impose a CPU CFS quota on the container. The number of microseconds per &lt;code>--cpu-period&lt;/code> that the container is limited to before throttled. As such acting as the effective ceiling. For most use-cases, &lt;code>--cpus&lt;/code> is a more convenient alternative.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--cpuset-cpus&lt;/code>&lt;/td>
&lt;td>Limit the specific CPUs or cores a container can use. A comma-separated list or hyphen-separated range of CPUs a container can use, if you have more than one CPU. The first CPU is numbered 0. A valid value might be &lt;code>0-3&lt;/code> (to use the first, second, third, and fourth CPU) or &lt;code>1,3&lt;/code> (to use the second and fourth CPU).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>--cpu-shares&lt;/code>&lt;/td>
&lt;td>Set this flag to a value greater or less than the default of 1024 to increase or reduce the container’s weight, and give it access to a greater or lesser proportion of the host machine’s CPU cycles. This is only enforced when CPU cycles are constrained. When plenty of CPU cycles are available, all containers use as much CPU as they need. In that way, this is a soft limit. &lt;code>--cpu-shares&lt;/code> does not prevent containers from being scheduled in swarm mode. It prioritizes container CPU resources for the available CPU cycles. It does not guarantee or reserve any specific CPU access.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># If you have 1 CPU, each of the following commands guarantees the container at most 50% of the CPU every second.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --cpus&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;.5&amp;#34;&lt;/span> ubuntu /bin/bash
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Which is the equivalent to manually specifying --cpu-period and --cpu-quota;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -it --cpu-period&lt;span class="o">=&lt;/span>&lt;span class="m">100000&lt;/span> --cpu-quota&lt;span class="o">=&lt;/span>&lt;span class="m">50000&lt;/span> ubuntu /bin/bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;p>&lt;a class="link" href="https://hub.docker.com/r/polinux/stress" target="_blank" rel="noopener"
>stress&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用stress镜像 进行测试&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker run -ti --rm polinux/stress stress --cpu &lt;span class="m">1&lt;/span> --io &lt;span class="m">1&lt;/span> --vm &lt;span class="m">1&lt;/span> --vm-bytes 128M --timeout 1s --verbose
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示容器的运行进程&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker top CONTAINER
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 显示容器资源使用统计的实时流&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ docker stats
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>